#!/usr/bin/nickle
/*
 * Copyright Â© 2023 Keith Packard <keithp@keithp.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
 */

autoload Cairo;

autoload Nichrome;
autoload Nichrome::Box;
autoload Nichrome::Label;
autoload Nichrome::Button;
autoload Nichrome::Textline;
autoload JSON;
autoload ParseArgs;

autoload Sort;

string glyph_list_name = "glyphlist.txt";
string font_name = "Frutiger LT Std-12";

typedef struct {
	real	left_side_bearing;
	real	right_side_bearing;
	real	width;
	real	ascent;
	real	descent;
} metrics_t;

typedef struct {
	int		ucs4;
	metrics_t	metrics;
	real[...]	snap_x;
	real[...]	snap_y;
	real[...]	outline;
} glyph_t;

typedef struct {
	string		name;
	string		style;
	string[...]	metadata;
	real		units_per_em;
	real		ascent;
	real		descent;
	real		cap_height;
	real		x_height;
	glyph_t[int]	glyphs;
} font_t;

glyph_t sample_glyph = {
	.ucs4 = 0xae,
	.metrics = {
		.left_side_bearing = 0,
		.right_side_bearing = 30,
		.width = 42,
		.ascent = 34,
		.descent = 0,
	},
	.snap_x = { 0, 9, 24},
	.snap_y = {-28, -25, -15, 0},
	.outline = {
    'm', 15, -30,
    'c', 6, -30, 0, -24, 0, -15,
    'c', 0, -6, 6, 0, 15, 0,
    'c', 24, 0, 30, -6, 30, -15,
    'c', 30, -24, 24, -30, 15, -30,
    'm', 9, -5,
    'l', 9, -25,
    'l', 18, -25,
    'c', 24, -25, 24, -15, 18, -15,
    'l', 9, -15,
    'm', 16, -15,
    'l', 22, -5,
    'e',
	}
};

font_t sample_font = {
	.name = "sample",
	.style = "all",
	.metadata = {},
	.units_per_em = 64,
	.ascent = 50,
	.descent = 14,
	.cap_height = 42,
	.x_height = 28,
	.glyphs = { sample_glyph.ucs4 => sample_glyph },
};

int
first_ucs4 (&font_t font)
{
	int[...] keys = hash_keys(font.glyphs);

	if (dim(keys) == 0)
		return 0;

	bool key_gt(int a, int b) { return a > b; }

	Sort::qsort(&keys, key_gt);
	return keys[0];
}

int
next_ucs4 (&font_t font, int ucs4)
{
	int[...] keys = hash_keys(font.glyphs);

	if (dim(keys) == 0)
		return 0;

	bool key_gt(int a, int b) { return a > b; }

	Sort::qsort(&keys, key_gt);
	for (int i = 0; i < dim(keys); i++)
		if (keys[i] > ucs4)
			return keys[i];
	return keys[dim(keys)-1];
}

int
prev_ucs4 (&font_t font, int ucs4)
{
	int[...] keys = hash_keys(font.glyphs);

	if (dim(keys) == 0)
		return 0;

	bool key_gt(int a, int b) { return a > b; }

	Sort::qsort(&keys, key_gt);
	for (int i = dim(keys)-1; i >= 0; i--)
		if (keys[i] < ucs4)
			return keys[i];
	return keys[0];
}

/*
 * Draw callbacks provided to the glyph drawing function
 */
typedef struct {
	void(real x, real y) move;
	void(real x, real y) line;
	void(real x1, real y1, real x2, real y2, real x3, real y3) curve;
	void(int offset) offset;
	real flatness;
} draw_calls_t;

typedef struct {
	real	x, y;
} spoint_t;

typedef struct {
	spoint_t    a, b, c, d;
} spline_t;

typedef struct {
	spoint_t	top_left;
	spoint_t	bottom_right;
} rect_t;

bool
rect_is_empty(*rect_t r)
{
	return r->top_left.x >= r->bottom_right.x || r->top_left.y >= r->bottom_right.y;
}

/* Interpolate splines to lines until we hit the desired flatness */
void
_lerp_half (*spoint_t a, *spoint_t b, *spoint_t result)
{
	result->x = a->x + ((b->x - a->x) / 2);
	result->y = a->y + ((b->y - a->y) / 2);
}

void
de_casteljau (*spline_t spline, *spline_t s1, *spline_t s2)
{
	spoint_t ab, bc, cd;
	spoint_t abbc, bccd;
	spoint_t final;

	_lerp_half (&spline->a, &spline->b, &ab);
	_lerp_half (&spline->b, &spline->c, &bc);
	_lerp_half (&spline->c, &spline->d, &cd);
	_lerp_half (&ab, &bc, &abbc);
	_lerp_half (&bc, &cd, &bccd);
	_lerp_half (&abbc, &bccd, &final);

	s1->a = spline->a;
	s1->b = ab;
	s1->c = abbc;
	s1->d = final;

	s2->a = final;
	s2->b = bccd;
	s2->c = cd;
	s2->d = spline->d;
}

/*
 * Return an upper bound on the error (squared * 16) that could
 * from approximating a spline as a line segment
 * the two endpoints
 *
 * From https://hcklbrrfnn.files.wordpress.com/2012/08/bez.pdf
 */
real error_squared(*spline_t spline)
{
	real ux = 3 * spline->b.x - 2 * spline->a.x - spline->d.x;
	real uy = 3 * spline->b.y - 2 * spline->a.y - spline->d.y;
        real vx = 3 * spline->c.x - 2 * spline->d.x - spline->a.x;
	real vy = 3 * spline->c.y - 2 * spline->d.y - spline->a.y;

	ux *= ux;
	uy *= uy;
	vx *= vx;
	vy *= vy;
	if (ux < vx)
		ux = vx;
	if (uy < vy)
		uy = vy;
	return ux + uy;
}

spline_t[...] decompose(*spline_t spline, real tolerance)
{
        if (error_squared(spline) <= 16 * tolerance * tolerance)
		return (spline_t[...]) { *spline };
	spline_t s1, s2;
	de_casteljau(spline, &s1, &s2);
	spline_t[...] s1a = decompose(&s1, tolerance);
	spline_t[...] s2a = decompose(&s2, tolerance);
	return (spline_t[dim(s1a) + dim(s2a)]) { [i] = i < dim(s1a) ? s1a[i] : s2a[i - dim(s1a)] };
}


real glyph_scale = 1;
real glyph_round = 0.1;

real
coord(real coord)
{
	return floor(coord * glyph_scale / glyph_round + 0.5) * glyph_round;
}

/*
 * Draw a glyph using the provide callbacks.
 */
void
glyph_path(&glyph_t glyph, &draw_calls_t calls)
{
	real	x1, y1, x2, y2, x3, y3, _x1, _y1;
	int	op;
	int	offset = 0;

	x1 = y1 = 0;

	real value() { return glyph.outline[offset++]; }

	for (;;) {
		if (!is_uninit(&calls.offset))
			calls.offset(offset);
		op = value();

		switch (op) {
		case 'm':
			x1 = value();
			y1 = value();
			calls.move (x1, y1);
			continue;
		case 'l':
			x1 = value();
			y1 = value();
			calls.line (x1, y1);
			continue;
		case 'c':
			x3 = value();
			y3 = value();
			x2 = value();
			y2 = value();
			x1 = value();
			y1 = value();
			calls.curve (x3, y3, x2, y2, x1, y1);
			continue;
		case '2':
			/* Compute the equivalent cubic spline */
			_x1 = value();
			_y1 = value();
			x3 = x1 + 2 * (_x1 - x1) / 3;
			y3 = y1 + 2 * (_y1 - y1) / 3;
			x1 = value();
			y1 = value();
			x2 = x1 + 2 * (_x1 - x1) / 3;
			y2 = y1 + 2 * (_y1 - y1) / 3;
			calls.curve (x3, y3, x2, y2, x1, y1);
			continue;
		case 'e':
			break;
		default:
			printf("unknown glyph op 0x%02x '%c'\n", op, op);
			break;
		}
		break;
	}
}

public metrics_t measure_ink(&glyph_t glyph)
{
	real min_x = 1e50;
	real max_x = -1e50;
	real min_y = 1e50;
	real max_y = -1e50;

	real cur_x, cur_y;

	void bounds(real x, real y)
	{
		min_x = min(x, min_x);
		min_y = min(y, min_y);
		max_x = max(x, max_x);
		max_y = max(y, max_y);
		cur_x = x;
		cur_y = y;
	}

	void ink_move(real x, real y)
	{
		bounds(x, y);
	}

	void ink_line(real x, real y)
	{
		bounds(x, y);
	}

	void ink_curve(real x1, real y1, real x2, real y2, real x3, real y3)
	{
		spline_t s = {
			.a = { .x = cur_x, .y = cur_y },
			.b = { .x = x1, .y = y1 },
			.c = { .x = x2, .y = y2 },
			.d = { .x = x3, .y = y3 }
		};
		spline_t[...] d = decompose(&s, 0.0001);
		for (int i = 0; i < dim(d); i++)
			ink_line(d[i].d.x, d[i].d.y);
	}

	draw_calls_t ink_calls = {
		.move = ink_move,
		.line = ink_line,
		.curve = ink_curve,
	};

	glyph_path(&glyph, &ink_calls);

	if (min_x > max_x) {
		min_x = max_x = 0;
	}
	if (min_y > max_y) {
		max_y = min_y = 0;
	}
	return (metrics_t) {
		.left_side_bearing = floor(min_x),
		.right_side_bearing = ceil(max_x),
		.width = glyph.metrics.width,
		.ascent = -floor(min_y),
		.descent = ceil(max_y)
	};
}

void print_outline(file f, &real[...] outline)
{
	int offset = 0;
	bool done = false;
	while (!done) {
		File::fprintf(f, "    '%c',", outline[offset]);
		int count = 0;
		switch (outline[offset++]) {
		case 'm':
		case 'l':
			count = 2;
			break;
		case 'c':
			count = 6;
			break;
		case '2':
			count = 4;
			break;
		case 'e':
			done = true;
			count = 0;
		default:
			done = true;
			count = 0;
		}
		for (int i = 0; i < count; i++)
			File::fprintf(f, " %f,", outline[offset++]);
		File::fprintf(f, "\n");
	}
}

void print_glyph(file f, &glyph_t glyph)
{
	&metrics_t metrics = &glyph.metrics;
	File::fprintf(f, "   0x%02x, # '%c'\n", glyph.ucs4, glyph.ucs4);
	File::fprintf(f, "    %f, %f, %f, %f, %f, %d, %d,\n",
		      metrics.left_side_bearing,
		      metrics.right_side_bearing,
		      metrics.width,
		      metrics.ascent,
		      metrics.descent,
		      dim(glyph.snap_x),
		      dim(glyph.snap_y));
	File::fprintf(f, "   ");
	for (int i = 0; i < dim(glyph.snap_x); i++)
		File::fprintf(f, " %f,", glyph.snap_x[i]);
	File::fprintf(f, " #  snap_x\n");
	File::fprintf(f, "   ");
	for (int i = 0; i < dim(glyph.snap_y); i++)
		File::fprintf(f, " %f,", glyph.snap_y[i]);
	File::fprintf(f, " #  snap_y\n");
	print_outline(f, &glyph.outline);
}

real[...] parse_line(string line)
{
	real[...] elts = {};
	line = String::split(line, "#")[0];
	string[*] bits = String::parse_csv(line);
	for (int i = 0; i < dim (bits); i++) {
		if (String::length(bits[i]) == 0)
			continue;
		string elt = String::chomp(bits[i]);
		real value = 0;
		if (elt[0] == '\'')
			value = elt[1];
		else
			value = string_to_real(elt);
		elts[dim(elts)] = value;
	}
	return elts;
}

glyph_t read_glyph(file f)
{
	string ucs_line = File::fgets(f);
	int ucs4 = parse_line(ucs_line)[0];

	string metrics_line = File::fgets(f);
	real[...] metrics_bits = parse_line(metrics_line);

	bool has_width = (dim(metrics_bits) == 7);

	int after_width = has_width ? 1 : 0;

	metrics_t metrics = (metrics_t) {
		.left_side_bearing = metrics_bits[0],
		.right_side_bearing = metrics_bits[1],
		.width = has_width ? metrics_bits[2] : metrics_bits[1] + 12,
		.ascent = metrics_bits[2 + after_width],
		.descent = metrics_bits[3 + after_width],
	};

	int n_snap_x = metrics_bits[4 + after_width];
	int n_snap_y = metrics_bits[5 + after_width];

	string snap_x_line = File::fgets(f);
	real[...] snap_x = parse_line(snap_x_line);

	string snap_y_line = File::fgets(f);
	real[...] snap_y = parse_line(snap_y_line);

	bool done = false;
	real[...] outline = {};

	while(!done) {
		string line = File::fgets(f);
		string[*] bits = String::parse_csv(line);
		real[...] add = parse_line(line);
		if (dim(add) > 0)
			outline = (real[dim(outline) + dim(add)]) { [i] = i < dim(outline) ? outline[i] : add[i-dim(outline)] };
		if (add[0] == 'e')
			done = true;
	}
	return (glyph_t) {
		.ucs4 = ucs4,
		.metrics = metrics,
		.snap_x = snap_x,
		.snap_y = snap_y,
		.outline = outline
	};
}

extend namespace Nichrome {
	public namespace Glyphed {

		import Cairo;

		const int rows = 64;
		const int cols = 64;

		protected typedef bool (&widget_t widget, string key) key_callback_t;

		protected typedef void (&widget_t widget, string message) info_callback_t;

		protected typedef void (&widget_t widget, string message) error_callback_t;

		public typedef widget_t + struct {
			key_callback_t	key_callback;
			info_callback_t	info_callback;
			error_callback_t error_callback; 
			rgba_color_t	path;
			rgba_color_t	stroke;
			rgba_color_t	highlight;
			rgba_color_t	bounds;
			rgba_color_t	bounds_high;
			rgba_color_t	spot;
			rgba_color_t	select;
			rgba_color_t	grid;
			rgba_color_t	baseline;
			&font_t		font;
			&glyph_t	glyph;
			real		step_size;
			bool		shift;
			bool		changed;
			int		start_coord;
			int		end_coord;
			int		max_coord;
			int		cur_offset;
			int		cur_element;
			real		line_width;
		} glyphed_t;

		const int min_coord = -5;
		const int lsb_coord = -5;
		const int rsb_coord = -4;
		const int width_coord = -3;
		const int ascent_coord = -2;
		const int descent_coord = -1;

		void info(&glyphed_t glyphed, string format, args...) {
			if (!is_uninit(&glyphed.info_callback))
				glyphed.info_callback(&glyphed, sprintf(format, args...));
		}

		void error(&glyphed_t glyphed, string format, args...) {
			if (!is_uninit(&glyphed.error_callback))
				glyphed.error_callback(&glyphed, sprintf(format, args...));
		}

		bool has_focus(&glyphed_t glyphed) {
			return &glyphed == &glyphed.nichrome.key_focus;
		}

		string bound_info(&glyphed_t glyphed, int bound) {
			&metrics_t metrics = &glyphed.glyph.metrics;
			switch (bound) {
			case lsb_coord:
				return sprintf("left side bearing <%f>", metrics.left_side_bearing);
			case rsb_coord:
				return sprintf("right side bearing <%f>", metrics.right_side_bearing);
			case width_coord:
				return sprintf("width <%f>", metrics.width);
			case ascent_coord:
				return sprintf("ascent <%f>", metrics.ascent);
			case descent_coord:
				return sprintf("descent <%f>", metrics.descent);
			default:
				return "???";
			}
		}

		int offset_to_coord(&glyphed_t glyphed, int dest_offset)
		{
			int dest_coord = -1;
			int cur_coord = 0;
			int cur_offset;

			void coord_offset(int offset)
			{
				cur_offset = offset;
			}

			void check_coord(int o)
			{
				int coord_offset = cur_offset + 1 + 2 * o;
				if (coord_offset >= dest_offset && dest_coord == -1)
					dest_coord = cur_coord;
				cur_coord++;
			}

			void coord_move(real x, real y)
			{
				check_coord(0);
			}

			void coord_line(real x, real y)
			{
				check_coord(0);
			}

			void coord_curve(real x1, real y1, real x2, real y2, real x3, real y3)
			{
				for (int i = 0; i < 3; i++)
					check_coord(i);
			}

			draw_calls_t coord_calls = {
				.move = coord_move,
				.line = coord_line,
				.curve = coord_curve,
				.offset = coord_offset
			};

			glyph_path(&glyphed.glyph, &coord_calls);
			return dest_coord;
		}

		/* Convert a coordinate number to the offset of
		 * the containing element within the outline and
		 * the offset of the X value (Y is +1).
		 * Returns {-1, -1} if the coord is not valid
		 */
		int[2] coord_to_offsets(&glyphed_t glyphed, int coord)
		{
			int cur_offset;
			int cur_coord = 0;
			int[2] ret_offsets = { -1, -1 };

			void coord_offset(int offset)
			{
				cur_offset = offset;
			}

			void check_coord(int o)
			{
				if (cur_coord == coord) {
					ret_offsets[0] = cur_offset;
					ret_offsets[1] = cur_offset + 1 + 2 * o;
				}
				cur_coord++;
			}

			void coord_move(real x, real y)
			{
				check_coord(0);
			}

			void coord_line(real x, real y)
			{
				check_coord(0);
			}

			void coord_curve(real x1, real y1, real x2, real y2, real x3, real y3)
			{
				for (int i = 0; i < 3; i++)
					check_coord(i);
			}

			draw_calls_t coord_calls = {
				.move = coord_move,
				.line = coord_line,
				.curve = coord_curve,
				.offset = coord_offset
			};

			glyph_path(&glyphed.glyph, &coord_calls);
			return ret_offsets;
		}

		int coord_to_offset(&glyphed_t glyphed, int coord)
		{
			return coord_to_offsets(&glyphed, coord)[1];
		}

		int coord_to_element(&glyphed_t glyphed, int coord)
		{
			return coord_to_offsets(&glyphed, coord)[0];
		}

		int max_coord(&glyphed_t glyphed)
		{
			int coord = dim(glyphed.glyph.outline);

			while (coord >= 0) {
				if (coord_to_offset(&glyphed, coord) >= 0)
					return coord;
				coord--;
			}
			return -1;
		}

		bool is_selected(&glyphed_t glyphed, int coord, int num)
		{
			if (glyphed.start_coord <= glyphed.end_coord)
				return glyphed.start_coord < coord + num && coord <= glyphed.end_coord;
			else
				return glyphed.end_coord < coord + num && coord <= glyphed.start_coord;
		}

		void bound(cairo_t cr, &glyphed_t glyphed, int bound)
		{
			if (has_focus(&glyphed) && is_selected(&glyphed, bound, 1)) {
				set_source_rgba(cr, glyphed.bounds_high.red, glyphed.bounds_high.green,
						glyphed.bounds_high.blue, glyphed.bounds_high.alpha);
				set_line_width(cr, 0.5);
				info (&glyphed, bound_info(&glyphed, bound));
			} else {
				set_source_rgba(cr, glyphed.bounds.red, glyphed.bounds.green,
						glyphed.bounds.blue, glyphed.bounds.alpha);
				set_line_width(cr, 0.25);
			}
			&metrics_t metrics = &glyphed.glyph.metrics;

			real	x1 = metrics.left_side_bearing;
			real	y1 = -metrics.ascent;
			real	x2 = metrics.right_side_bearing;
			real	y2 = metrics.descent;

			switch (bound) {
			case lsb_coord:
				x1 = x2 = metrics.left_side_bearing;
				break;
			case rsb_coord:
				x1 = x2 = metrics.right_side_bearing;
				break;
			case width_coord:
				x1 = 0;
				x2 = metrics.width;
				y1 = 0;
				y2 = 0;
				break;
			case ascent_coord:
				y1 = y2 = -metrics.ascent;
				break;
			case descent_coord:
				y1 = y2 = metrics.descent;
				break;
			}
			move_to(cr, x1, y1);
			line_to(cr, x2, y2);
			stroke(cr);
			if (bound == width_coord) {
				set_source_rgba(cr, glyphed.bounds_high.red, glyphed.bounds_high.green,
						glyphed.bounds_high.blue, glyphed.bounds_high.alpha);
				arc(cr, x2, y2, .75, 0, 2 * pi);
				fill(cr);
			}
		}

		void draw_bounds(cairo_t cr, &glyphed_t glyphed)
		{
			&glyph_t glyph = &glyphed.glyph;
			&metrics_t metrics = &glyph.metrics;
			save(cr);
			translate(cr, 0, glyphed.font.ascent);
			bound(cr, &glyphed, lsb_coord);
			bound(cr, &glyphed, rsb_coord);
			bound(cr, &glyphed, width_coord);
			bound(cr, &glyphed, ascent_coord);
			bound(cr, &glyphed, descent_coord);
			restore(cr);
		}

		void draw_char(cairo_t cr, &glyphed_t glyphed)
		{
			string s = sprintf("%c", glyphed.glyph.ucs4);
			twixt(save(cr); restore(cr)) {
				set_font(cr, font_name);
				set_source_rgba(cr, 0, 0, 0, 0.15);
				text_extents_t ma = text_extents(cr, "I");

				text_extents_t m = text_extents(cr, s);
				if (m.width == 0 || m.height == 0)
					return;
				real stroke_width = 2.0;
				real stroke_height = 2.0;
				&metrics_t metrics = &glyphed.glyph.metrics;
				if (metrics.right_side_bearing == metrics.left_side_bearing &&
				    metrics.ascent == -metrics.descent)
					return;
				real actual_width = (metrics.right_side_bearing - metrics.left_side_bearing) + stroke_width;
				real actual_height = glyphed.font.cap_height + stroke_height;
				real scale_y = actual_height / ma.height;
				translate(cr, 0, glyphed.font.ascent);
				scale(cr, scale_y, scale_y);
				move_to(cr, 0, 0);
				show_text(cr, s);
				move_to(cr, 0, 0);
				line_to(cr, m.x_advance, 0);
				stroke(cr);
			}

		}

		void draw_glyph(cairo_t cr, &glyphed_t glyphed)
		{
			&glyph_t glyph = &glyphed.glyph;

			void whole_move(real x, real y) {
				move_to(cr, x, y);
			}

			void whole_line(real x, real y) {
				line_to(cr, x, y);
			}

			void whole_curve(real x1, real y1, real x2, real y2, real x3, real y3) {
				curve_to(cr, x1, y1, x2, y2, x3, y3);
			}

			draw_calls_t whole_calls = {
				.move = whole_move,
				.line = whole_line,
				.curve = whole_curve
			};

			int cur_coord;

			void highlight_move(real x, real y)
			{
				move_to(cr, x, y);
				cur_coord++;
			}

			void highlight_line(real x, real y)
			{
				if (is_selected(&glyphed, cur_coord, 1))
					line_to(cr, x, y);
				else
					move_to(cr, x, y);
				cur_coord++;
			}

			void highlight_curve(real x1, real y1, real x2, real y2, real x3, real y3)
			{
				if (is_selected(&glyphed, cur_coord, 3))
					curve_to(cr, x1, y1, x2, y2, x3, y3);
				else
					move_to(cr, x3, y3);
				cur_coord += 3;
			}

			draw_calls_t highlight_calls  = {
				.move = highlight_move,
				.line = highlight_line,
				.curve = highlight_curve,
			};

			int cur_offset;

			bool spot(int coord, real x, real y)
			{
				bool ret = false;
				if (is_selected(&glyphed, cur_coord + coord, 1)) {
					set_source_rgba(cr, glyphed.select.red, glyphed.select.green,
							glyphed.select.blue, glyphed.select.alpha);
					glyphed.cur_offset = cur_offset + 1 + 2 * coord;
					glyphed.cur_element = cur_offset;
					ret = true;
				} else
					set_source_rgba(cr, glyphed.spot.red, glyphed.spot.green,
							glyphed.spot.blue, glyphed.spot.alpha);
				arc(cr, x, y, 0.5, 0, pi * 2);
				fill(cr);
				return ret;
			}

			void spot_offset(int offset)
			{
				cur_offset = offset;
			}

			real cur_x, cur_y;

			void spot_move(real x, real y)
			{
				if (is_selected(&glyphed, cur_coord, 1))
					if (spot(0, x, y))
						info(&glyphed, "move <%f %f>", x, y);
				cur_x = x;
				cur_y = y;
				cur_coord++;
			}

			void spot_line(real x, real y)
			{
				if (is_selected(&glyphed, cur_coord, 1))
					if (spot(0, x, y))
						info(&glyphed, "line <%f %f> - <%f %f> [%f %f]", cur_x, cur_y, x, y, x - cur_x, y - cur_y);
				cur_x = x;
				cur_y = y;
				cur_coord++;
			}

			void spot_curve(real x1, real y1, real x2, real y2, real x3, real y3)
			{
				if (is_selected(&glyphed, cur_coord, 3)) {
					bool chatty = false;
					if (spot(0, x1, y1))
						chatty = true;
					if (spot(1, x2, y2))
						chatty = true;
					if (spot(2, x3, y3))
						chatty = true;
					if (chatty)
						info(&glyphed, "curve <%f %f> <%f %f> [%f %f] {%f %f} <%f %f> [%f %f] {%f %f} <%f %f> [%f %f]",
						     cur_x, cur_y,
						     x1, y1, x1 - cur_x, y1 - cur_y, x1 - x3, y1 - y3,
						     x2, y2, x2 - cur_x, y2 - cur_y, x2 - x3, y2 - y3,
						     x3, y3, x3 - cur_x, y3 - cur_y);
				}
				cur_x = x3;
				cur_y = y3;
				cur_coord += 3;
			}

			draw_calls_t spot_calls = {
				.move = spot_move,
				.line = spot_line,
				.curve = spot_curve,
				.offset = spot_offset,
			};

			save(cr);
			translate(cr, 0, glyphed.font.ascent);
			set_line_cap(cr, line_cap_t.ROUND);
			set_line_join(cr, line_join_t.ROUND);

			set_line_width(cr, glyphed.line_width);
			set_source_rgba(cr, glyphed.stroke.red, glyphed.stroke.green,
					glyphed.stroke.blue, glyphed.stroke.alpha);
			glyph_path(&glyph, &whole_calls);
			stroke(cr);

			if (has_focus(&glyphed)) {
				set_line_width(cr, glyphed.line_width);
				set_line_cap(cr, line_cap_t.ROUND);
				set_line_join(cr, line_join_t.ROUND);
				cur_coord = 0;
				set_source_rgba(cr, glyphed.highlight.red, glyphed.highlight.green,
						glyphed.highlight.blue, glyphed.highlight.alpha);
				glyph_path(&glyph, &highlight_calls);
				stroke(cr);
				glyphed.start_coord = min(glyphed.start_coord, cur_coord - 1);
				glyphed.end_coord = min(glyphed.end_coord, cur_coord - 1);
				glyphed.max_coord = cur_coord;
				cur_coord = 0;
				glyphed.cur_offset = -1;
				glyphed.cur_element = -1;
				glyph_path(&glyph, &spot_calls);
			}
			set_line_width(cr, 0.1);
			set_source_rgba(cr, glyphed.path.red, glyphed.path.green,
					glyphed.path.blue, glyphed.path.alpha);
			glyph_path(&glyph, &whole_calls);
			stroke(cr);
			restore(cr);
		}

		void draw_grid(cairo_t cr, &glyphed_t glyphed) {
			for (int col = 0; col < cols; col++) {
				real alpha = glyphed.grid.alpha;
				if (col % 5 == 0)
					set_line_width(cr, 0.05);
				else
					set_line_width(cr, 0.025);
				set_source_rgba(cr, glyphed.grid.red, glyphed.grid.green,
						glyphed.grid.blue, glyphed.grid.alpha);
				move_to(cr, col, -0.5);
				line_to(cr, col, rows - 0.5);
				stroke(cr);
			}
			for (int row = 0; row < rows; row++) {
				if (row == glyphed.font.ascent) {
					set_source_rgba(cr, glyphed.baseline.red, glyphed.baseline.green,
							glyphed.baseline.blue, glyphed.baseline.alpha);
					set_line_width(cr, 0.1);
				} else {
					real alpha = glyphed.grid.alpha;
					if (row % 5 != 0)
						alpha = alpha / 2;
					set_source_rgba(cr, glyphed.grid.red, glyphed.grid.green,
							glyphed.grid.blue, alpha);
					set_line_width(cr, 2/rows);
				}
				move_to(cr, -0.5, row);
				line_to(cr, cols - 0.5, row);
				stroke(cr);
			}
		}

		void paint(cairo_t cr, &glyphed_t glyphed) {
			real size = min(glyphed.geometry.width, glyphed.geometry.height);
			real pad_x = size / 20;
			real pad_y = size / 20;
			real delta_x = (size - pad_x * 2) / rows;
			real off_x = pad_x + delta_x / 2 + (glyphed.geometry.width - size) / 2;
			real delta_y = (size - pad_y * 2) / cols;
			real off_y = pad_y + delta_y / 2 + (glyphed.geometry.height - size) / 2;

			translate(cr, off_x, off_y);
			scale(cr, delta_x, delta_y);
			draw_char(cr, &glyphed);
			draw_glyph(cr, &glyphed);
			draw_bounds(cr, &glyphed);
			draw_grid(cr, &glyphed);
			move_to(cr, -100, -100);
			line_to(cr, -90, -90);
		}

		void draw(cairo_t cr, &glyphed_t glyphed) {
			paint(cr, &glyphed);
		}

		void print(&glyphed_t glyphed, int indent) {
			do_indent(indent);
			printf("glyphed %v\n", glyphed.geometry);
		}

		void natural(cairo_t cr, &glyphed_t glyphed) {
			rectangle(cr, 0, 0, 1024, 1024);
		}

		void outline(cairo_t cr, &glyphed_t glyphed) {
			rectangle(cr, 0, 0, glyphed.geometry.width, glyphed.geometry.height);
		}

		*real get_ref(&glyphed_t glyphed, int coord, bool y)
		{
			switch (coord) {
			case lsb_coord:
				return &glyphed.glyph.metrics.left_side_bearing;
			case rsb_coord:
				return &glyphed.glyph.metrics.right_side_bearing;
			case width_coord:
				return &glyphed.glyph.metrics.width;
			case ascent_coord:
				return &glyphed.glyph.metrics.ascent;
			case descent_coord:
				return &glyphed.glyph.metrics.descent;
			default:
				break;
			}
			int offset = coord_to_offset(&glyphed, coord);
			if (y)
				return &glyphed.glyph.outline[offset + 1];
			else
				return &glyphed.glyph.outline[offset];
		}

		typedef struct {
			int first;
			int last;
		} coord_range_t;

		coord_range_t coord_range(&glyphed_t glyphed) {
			if (glyphed.start_coord <= glyphed.end_coord)
				return (coord_range_t) {
					.first = glyphed.start_coord,
					.last = glyphed.end_coord
				};
			else
				return (coord_range_t) {
					.first = glyphed.end_coord,
					.last = glyphed.start_coord
				};
		}

		void step_coord(&glyphed_t glyphed, real step, bool y)
		{
			coord_range_t range = coord_range(&glyphed);
			for (int coord = range.first; coord <= range.last; coord++) {
				*get_ref(&glyphed, coord, y) += step;
			}
		}

		int element_space(int type) {
			switch (type) {
			case 'e':
				return 1;
			case 'm':
			case 'l':
				return 3;
			case 'c':
				return 7;
			case '2':
				return 5;
			default:
				printf("unknown element %d\n", type);
				return 1;
			}
		}

		int coord_space(int type) {
			switch (type) {
			case 'e':
				return 0;
			case 'm':
			case 'l':
				return 1;
			case 'c':
				return 3;
			case '2':
				return 2;
			default:
				printf("unknown element %d\n", type);
				return 0;
			}
		}

		void append(&glyphed_t glyphed, int type) {
			int this_space = element_space(type);
			&glyph_t glyph = &glyphed.glyph;

			int spot = glyphed.cur_element;
			if (spot < 0)
				spot = 0;

			int prev_type = glyph.outline[spot];
			int prev_space = element_space(prev_type);
			int prev_coord = coord_space(prev_type);

			/* insert before 'e' */
			if (prev_type == 'e')
				prev_space = 0;

			real x = 0;
			real y = 0;

			spot += prev_space;

			if (spot >= 3) {
				x = glyph.outline[spot-2];
				y = glyph.outline[spot-1];
			}

			real contents(int i) {
				if (i < spot)
					return glyph.outline[i];
				if (i == spot)
					return type;
				if (i < spot + this_space) {
					int dist = i - (spot + 1);
					return ((dist & 1) == 0) ? x : y;
				}
				return glyph.outline[i-this_space];
			}

			real[...] new_outline = (real[dim(glyph.outline) + this_space]) { [i] = contents(i) };

			if (glyphed.start_coord < 0)
				glyphed.start_coord = 0;
			else
				glyphed.start_coord += prev_coord;
			glyphed.end_coord = glyphed.start_coord;
			glyph.outline = new_outline;
		}

		/* Return the first coordinate of the element containing 'coord' */
		int first_coord(&glyphed_t glyphed, int coord)
		{
			int[2] offsets = coord_to_offsets(&glyphed, coord);
			if (offsets[0] == -1)
				return -1;

			int dist = (offsets[1] - (offsets[0] + 1)) / 2;

			return coord - dist;
		}

		real[...] delete_element(real[...]outline, int element)
		{
			int type = outline[element];
			if (type == 'e')
				return outline;

			int space = 0;
			switch (type) {
			case 'm':
			case 'l':
				space = 3;
				break;
			case '2':
				space = 5;
				break;
			case 'c':
				space = 7;
				break;
			}

			if (space > dim(outline))
				return outline;

			real contents(int i) {
				if (i < element)
					return outline[i];
				return outline[i+space];
			}

			return (real[dim(outline) - space]) { [i] = contents(i) };
		}

		real[...] insert_element(real[...] outline, int element, real[...] insert) {
			real contents(int i) {
				if (i < element)
					return outline[i];
				if (i < element + dim(insert))
					return insert[i - element];
				return outline[i - dim(insert)];
			}

			return (real[dim(outline) + dim(insert)]) { [i] = contents(i) };
		}

		void delete(&glyphed_t glyphed) {
			&glyph_t glyph = &glyphed.glyph;

			coord_range_t range = coord_range(&glyphed);

			int coord = range.last;
			real[...] outline = glyph.outline;
			while (coord >= range.first)
			{
				coord = first_coord(&glyphed, coord);
				if (coord == -1)
					break;
				int element = coord_to_element(&glyphed, coord);

				outline = delete_element(outline, element);
				coord--;
			}
			if (outline[0] != 'm' && outline[0] != 'e')
				outline = insert_element(outline, 0, (real[3]) { 'm', 0, 0 });

			glyph.outline = outline;
			glyphed.start_coord = range.first;
			glyphed.end_coord = glyphed.start_coord;
		}

		public void scale(&glyphed_t glyphed, real scale_x, real scale_y) {
			&glyph_t glyph = &glyphed.glyph;

			int cur_offset = 0;
			int cur_coord = 0;

			void scale(int c) {
				if (is_selected(&glyphed, cur_coord, 1)) {
					glyph.outline[cur_offset + 1 + c * 2] = coord(glyph.outline[cur_offset + 1 + c * 2] * scale_x);
					glyph.outline[cur_offset + 2 + c * 2] = coord(glyph.outline[cur_offset + 2 + c * 2] * scale_y);
				}
				cur_coord++;
			}

			void scale_offset(int offset)
			{
				cur_offset = offset;
			}

			void scale_move(real x, real y)
			{
				scale(0);
			}

			void scale_line(real x, real y)
			{
				scale(0);
			}

			void scale_curve(real x1, real y1, real x2, real y2, real x3, real y3)
			{
				scale(0);
				scale(1);
				scale(2);
			}

			draw_calls_t scale_calls = {
				.move = scale_move,
				.line = scale_line,
				.curve = scale_curve,
				.offset = scale_offset,
			};

			glyph_path(&glyph, &scale_calls);
			Widget::redraw(&glyphed);
		}

		public void paste(&glyphed_t glyphed, &glyph_t new_glyph)
		{
			&glyph_t glyph = &glyphed.glyph;
			real[...] new_outline = {};

			coord_range_t range = coord_range(&glyphed);

			if (range.first >= 0) {
				int first_element = coord_to_element(&glyphed, range.first);
				/* paste in starting bits */
				for (int i = 0; i < first_element; i++)
					new_outline[dim(new_outline)] = glyph.outline[i];
			}

			int first_offset = dim(new_outline);

			/* paste in new bits, skipping 'e' */
			for (int i = 0; i < dim(new_glyph.outline) - 1; i++)
				new_outline[dim(new_outline)] = new_glyph.outline[i];

			int last_offset = dim(new_outline);

			int last_element = coord_to_element(&glyphed, range.last);

			if (last_element >= 0) {
				/* append rest of original bits */
				for (int i = last_element; i < dim(glyph.outline); i++)
					new_outline[dim(new_outline)] = glyph.outline[i];
			} else {
				new_outline[dim(new_outline)] = 'e';
			}

			glyph.outline = new_outline;

			glyphed.start_coord = range.first;
			glyphed.end_coord = offset_to_coord(&glyphed, last_offset) - 1;
			if (glyphed.end_coord < glyphed.start_coord)
				glyphed.end_coord = glyphed.start_coord;

			Widget::redraw(&glyphed);
		}


		public bool mirror_curve(&glyphed_t glyphed)
		{
			&glyph_t glyph = &glyphed.glyph;

			coord_range_t range = coord_range(&glyphed);

			if (range.first < 0) {
				error(&glyphed, "no coords");
				return false;
			}

			if (range.first != range.last) {
				error(&glyphed, "more than one coord");
				return false;
			}

			int element = coord_to_element(&glyphed, range.first);

			int this_offset = coord_to_offset(&glyphed, range.first);

			&real[...] outline = &glyph.outline;

			if (outline[element] != 'c') {
				error(&glyphed, "element is %c", outline[element]);
				return false;
			}

			int other_coord;
			int root_coord;

			if (this_offset == element + 1) {
				other_coord = range.first - 2;
				root_coord = range.first - 1;
			} else if (this_offset == element + 3) {
				root_coord = range.first + 1;
				other_coord = range.first + 2;
			} else {
				error(&glyphed, "not in middle of curve offset is %d element is %d", this_offset, element);
				return false;
			}

			int other_element = coord_to_element(&glyphed, other_coord);

			if (outline[other_element] != 'c') {
				error(&glyphed, "other element is %c", outline[other_element]);
				return false;
			}

			int other_offset = coord_to_offset(&glyphed, other_coord);
			int root_offset = coord_to_offset(&glyphed, root_coord);

			real dx = outline[other_offset] - outline[root_offset];
			real dy = outline[other_offset+1] - outline[root_offset+1];

			real new_x = outline[root_offset] - dx;
			real new_y = outline[root_offset+1] - dy;

			outline[this_offset] = new_x;
			outline[this_offset+1] = new_y;

			return true;
		}

		public bool step_aspect(&glyphed_t glyphed, int dir)
		{
			&glyph_t glyph = &glyphed.glyph;

			coord_range_t range = coord_range(&glyphed);

			if (range.first < 0) {
				error(&glyphed, "no coords");
				return false;
			}

			if (range.first != range.last) {
				error(&glyphed, "more than one coord");
				return false;
			}

			int element = coord_to_element(&glyphed, range.first);

			int this_offset = coord_to_offset(&glyphed, range.first);

			&real[...] outline = &glyph.outline;

			if (outline[element] != 'c') {
				error(&glyphed, "element is %c", outline[element]);
				return false;
			}

			int root_coord;

			if (this_offset == element + 1) {
				root_coord = range.first - 1;
			} else if (this_offset == element + 3) {
				root_coord = range.first + 1;
			} else {
				error(&glyphed, "not in middle of curve offset is %d element is %d", this_offset, element);
				return false;
			}

			int root_offset = coord_to_offset(&glyphed, root_coord);

			real dx = outline[this_offset] - outline[root_offset];
			real dy = outline[this_offset+1] - outline[root_offset+1];

			real step_x;
			real step_y;

			if (dx == 0) {
				step_x = 0.0;
				step_y = 0.1;
			} else if (dy == 0) {
				step_x = 0.1;
				step_y = 0.0;
			} else {
				real factor = gcd(floor(abs(dx * 10)), floor(abs(dy * 10)));

				step_x = dx / factor;
				step_y = dy / factor;
			}

			real new_x = outline[this_offset] + dir * step_x;
			real new_y = outline[this_offset+1] + dir * step_y;

			outline[this_offset] = new_x;
			outline[this_offset+1] = new_y;

			return true;
		}

		public void set_ink(&glyphed_t glyphed) {
			metrics_t metrics = measure_ink(&glyphed.glyph);
			glyphed.glyph.metrics = metrics;
		}

		void key(&glyphed_t glyphed, &key_event_t key) {
			switch (key.key) {
			case "Shift_L":
			case "Shift_R":
				glyphed.shift = (key.type == key_type_t.press);
				return;
			}
			if (key.type != key_type_t.press)
				return;
			if (!is_uninit(&glyphed.key_callback))
				if (glyphed.key_callback(&glyphed, key.key))
					return;
			bool redraw = false;
			real step = glyphed.shift ? 0.1 : 1;
			switch (key.key) {
			case "Left":
				step_coord(&glyphed, -step, false);
				redraw = true;
				break;
			case "Right":
				step_coord(&glyphed, step, false);
				redraw = true;
				break;
			case "Up":
				step_coord(&glyphed, -step, true);
				redraw = true;
				break;
			case "Down":
				step_coord(&glyphed, step, true);
				redraw = true;
				break;
			case "plus":
				glyphed.end_coord = min(glyphed.end_coord + 1, glyphed.max_coord - 1);
				redraw = true;
				break;
			case "equal":
				coord_range_t range = coord_range(&glyphed);
				glyphed.start_coord = range.last + 1;
				if (glyphed.start_coord == glyphed.max_coord)
					glyphed.start_coord = min_coord;
				glyphed.end_coord = glyphed.start_coord;
				int test_offset = coord_to_offset(&glyphed, glyphed.end_coord);
				int test_coord = offset_to_coord(&glyphed, test_offset);
				redraw = true;
				break;
			case "underscore":
				glyphed.end_coord = max(glyphed.end_coord - 1, min_coord);
				redraw = true;
				break;
			case "minus":
				coord_range_t range = coord_range(&glyphed);
				glyphed.start_coord = range.first;
				if (glyphed.start_coord == min_coord)
					glyphed.start_coord = glyphed.max_coord;
				glyphed.start_coord--;
				glyphed.end_coord = glyphed.start_coord;
				redraw = true;
				break;
			case "A":
				glyphed.start_coord = 0;
				glyphed.end_coord = glyphed.start_coord;
				redraw = true;
			case "a":
				glyphed.start_coord = 0;
				glyphed.end_coord = max_coord(&glyphed);
				redraw = true;
				break;
			case "m":
				append(&glyphed, 'm');
				redraw = true;
				break;
			case "l":
				append(&glyphed, 'l');
				redraw = true;
				break;
			case "c":
				append(&glyphed, 'c');
				redraw = true;
				break;
			case "d":
				delete(&glyphed);
				redraw = true;
				break;
			case "r":
				scale(&glyphed, -1, 1);
				redraw = true;
				break;
			case "R":
				scale(&glyphed, 1, -1);
				redraw = true;
				break;
			case "i":
				set_ink(&glyphed);
				redraw = true;
				break;
			case "p":
				print_glyph(stdout, &glyphed.glyph);
				break;
			case "M":
				redraw = mirror_curve(&glyphed);
				break;
			case "bracketleft":
				redraw = step_aspect(&glyphed, -1);
				break;
			case "bracketright":
				redraw = step_aspect(&glyphed, 1);
				break;
			case "Shift_L":
			case "Shift_R":
				break;
			default:
				printf("unknown key %s\n", key.key);
				break;
			}
			if (redraw)
				Widget::redraw(&glyphed);
		}

		void button(&glyphed_t glyphed, &button_event_t event) {
			if (event.type == button_type_t.press)
				set_key_focus(&glyphed.nichrome, &glyphed);
		}

		public void init(&glyphed_t glyphed, &nichrome_t nichrome) {
			Widget::init(&nichrome, &glyphed);

			glyphed.draw = draw;
			glyphed.outline = outline;
			glyphed.natural = natural;
			glyphed.print = print;
			glyphed.key = key;
			glyphed.button = button;
			glyphed.line_width = .2;
			glyphed.step_size = 1;
			glyphed.shift = false;

			glyphed.grid = (rgba_color_t) {
				red = 0.5, green = 0.5, blue = 0.5, alpha = 1,
			};
			glyphed.baseline = (rgba_color_t) {
				red = 0, green = 0, blue = 0, alpha = 1
			};
			glyphed.path = (rgba_color_t) {
				red = 1, green = 1, blue = 1, alpha = 1
			};
			glyphed.stroke = (rgba_color_t) {
				red = 0, green = 0, blue = 0, alpha = 1
			};

			glyphed.highlight = (rgba_color_t) {
				red = 1, green = 0, blue = 0, alpha = 1
			};
			glyphed.spot = (rgba_color_t) {
				red = 0, green = 0, blue = 0.5, alpha = 1
			};
			glyphed.select = (rgba_color_t) {
				red = 0, green = 0, blue = 1, alpha = 1
			};
			glyphed.bounds = (rgba_color_t) {
				.red = 0, green = 0.3, blue = 0, alpha = 1
			};
			glyphed.bounds_high = (rgba_color_t) {
				.red = 0, green = 1, blue = 0, alpha = 1
			};
		}

		public void set_glyph(&glyphed_t glyphed, &glyph_t glyph) {
			&glyphed.glyph = &glyph;
			glyphed.start_coord = 0;
			glyphed.end_coord = glyphed.start_coord;
			Widget::redraw(&glyphed);
		}

		public void set_font(&glyphed_t glyphed, &font_t font) {
			&glyphed.font = &font;
			&glyphed.glyph = &font.glyphs[first_ucs4(&font)];
			glyphed.start_coord = 0;
			glyphed.end_coord = glyphed.start_coord;
			Widget::redraw(&glyphed);
		}

		public void set_key_callback(&glyphed_t glyphed, key_callback_t key_callback) {
			glyphed.key_callback = key_callback;
		}

		public void set_info_callback(&glyphed_t glyphed, info_callback_t info_callback) {
			glyphed.info_callback = info_callback;
		}

		public void set_error_callback(&glyphed_t glyphed, error_callback_t error_callback) {
			glyphed.error_callback = error_callback;
		}

		public &glyph_t get_glyph(&glyphed_t glyphed) {
			return &glyphed.glyph;
		}

		public *widget_t new(&nichrome_t nichrome, &font_t font, key_callback_t key_callback, info_callback_t info_callback, error_callback_t error_callback) {
			&glyphed_t glyphed = &(glyphed_t) {};

			&glyphed.font = &font;
			init(&glyphed, &nichrome);
			set_glyph(&glyphed, &font.glyphs[first_ucs4(&font)]);
			set_key_callback(&glyphed, key_callback);
			set_info_callback(&glyphed, info_callback);
			set_error_callback(&glyphed, error_callback);
			return &glyphed;
		}
	}
}

import Nichrome;

font_t read_font(file f)
{
	glyph_t[int] glyphs = {};
	while (!File::end(f)) {
		glyph_t g = read_glyph(f);
		glyphs[g.ucs4] = g;
	}
	return (font_t) {
		.name = "Twin Sans",
		.style = "all",
		.metadata = {
			"Font name:       Twin Sans",
			"License:         SIL Open Font License http://scripts.sil.org/OFL",
			"Created by:      Keith Packard",
			"A derivative of: Hershey Sans",
			"",
			"Prepared in 2023 and converted to SVG fonts",
			"in 2023 by Keith Packard, www.keithp.com",
		},
		.units_per_em = 64,
		.ascent = 50,
		.descent = 14,
		.cap_height = 42,
		.x_height = 28,
		.glyphs = glyphs
	};
}

real[string] metrics_json(&metrics_t metrics)
{
	return (real[string]) {
		"left_side_bearing" => metrics.left_side_bearing,
		"right_side_bearing" => metrics.right_side_bearing,
		"width" => metrics.width,
		"ascent" => metrics.ascent,
		"descent" => metrics.descent
	};
}

poly[...] outline_json(&real[...] outline)
{
	int	i = 0;
	int	n_coords = 0;

	poly next_outline() {
		real	val = outline[i++];
		if (n_coords == 0) {
			switch (val) {
			case 'm':
			case 'l':
				n_coords = 2;
				break;
			case 'c':
				n_coords = 6;
				break;
			case '2':
				n_coords = 4;
				break;
			}
			return String::new(val);
		} else {
			n_coords--;
			return val;
		}
	}
	return (poly[dim(outline)]) { [i] = next_outline() };
}

poly[string] glyph_json(&glyph_t glyph)
{
	return (poly[string]) {
		"ucs4" => glyph.ucs4,
		"metrics" => metrics_json(&glyph.metrics),
		"outline" => outline_json(&glyph.outline)
	};
}

poly[...] glyphs_json(&(glyph_t[int]) glyphs)
{
	int[...] keys = hash_keys(glyphs);

	bool key_gt(int a, int b) { return a > b; }

	Sort::qsort(&keys, key_gt);

	return (poly[dim(keys)]) { [i] = glyph_json(&glyphs[keys[i]]) };
}

void print_font_stf (file f, &font_t font)
{
	poly[string] font_json = {
		"name" => font.name,
		"style" => font.style,
		"metadata" => font.metadata,
		"units_per_em" => font.units_per_em,
		"ascent" => font.ascent,
		"descent" => font.descent,
		"cap_height" => font.cap_height,
		"x_height" => font.x_height,
		"glyphs" => glyphs_json(&font.glyphs)
	};

	JSON::to_json_file(f, font_json);
	File::fprintf(f, "\n");
}

poly
get_json(&poly[string] json, string key, poly def)
{
	if (hash_test(json, key))
		return json[key];
	return def;
}
metrics_t json_to_metrics(real[string] metrics_json)
{
	return (metrics_t) {
		.left_side_bearing = coord(metrics_json["left_side_bearing"]),
		.right_side_bearing = coord(metrics_json["right_side_bearing"]),
		.width = coord(metrics_json["width"]),
		.ascent = coord(metrics_json["ascent"]),
		.descent = coord(metrics_json["descent"])
	};
}

real[...] json_to_outline(poly[...] outline_json)
{
	return (real[dim(outline_json)]) { [i] = is_string(outline_json[i]) ? outline_json[i][0] : coord(outline_json[i]) };
}

glyph_t json_to_glyph(poly[string] glyph_json)
{
	return (glyph_t) {
		.ucs4 = glyph_json["ucs4"],
		.metrics = json_to_metrics(glyph_json["metrics"]),
		.snap_x = {},
		.snap_y = {},
		.outline = json_to_outline(glyph_json["outline"]),
	};
}

glyph_t[int] json_to_glyphs(poly[...] glyphs_json)
{
	glyph_t[int] glyphs = {};
	for (int i = 0; i < dim(glyphs_json); i++) {
		glyph_t glyph = json_to_glyph(glyphs_json[i]);
		glyphs[glyph.ucs4] = glyph;
	}
	return glyphs;
}

font_t
read_font_stf(file f) {
	poly[string] font_json = JSON::from_json_file(f);

	font_t font = {};
	font.name = get_json(&font_json, "name", "unknown");
	font.style = get_json(&font_json, "style", "all");
	font.metadata = get_json(&font_json, "metadata", (string[...]) {});
	font.units_per_em = coord(get_json(&font_json, "units_per_em", 64));
	font.ascent = coord(get_json(&font_json, "ascent", 0));
	font.descent = coord(get_json(&font_json, "descent", 0));
	font.cap_height = coord(get_json(&font_json, "cap_height", 0));
	font.x_height = coord(get_json(&font_json, "x_height", 0));
	font.glyphs = json_to_glyphs(font_json["glyphs"]);
	return font;
}

void print_font (file f, &font_t font)
{
	int[...] keys = hash_keys(font.glyphs);

	bool key_gt(int a, int b) { return a > b; }

	Sort::qsort(&keys, key_gt);
	for (int i = 0; i < dim(keys); i++)
		print_glyph(f, &font.glyphs[keys[i]]);
}

string[] svg_header = {
"<?xml version=\"1.0\" encoding=\"UTF-8\" ?>",
"<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\" >",
"",
"<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\">",
"",
"<metadata>",
};


string[] svg_footer = {
	"</font>",
	"</defs>",
	"</svg>"
};

real svg_em = 64;

real
svg_value(real value)
{
	return value * svg_em / 64;
}

bool svg_names_loaded = false;

string[int] svg_names = {};

string
svg_name(int ucs4)
{
	if (hash_test(svg_names, ucs4))
		return svg_names[ucs4];
	return sprintf("Unknown glyph 0x%x", ucs4);
}

void
load_svg_names(string filename)
{
	if (svg_names_loaded)
		return;
	svg_names_loaded = true;

	twixt(file f = File::open(filename, "r"); File::close(f)) {
		while (!File::end(f)) {
			string line = File::fgets(f);
			if (line[0] == '#')
				continue;
			string[*] words = String::wordsplit(String::chump(line), ";");
			if (dim(words) == 2) {
				int ucs4 = string_to_integer(words[1], 16);
				svg_names[ucs4] = words[0];
			}
		}
	}
}

void print_glyph_svg (file f, &font_t font, &glyph_t glyph)
{
	string charname;
	&metrics_t metrics = &glyph.metrics;

	switch (glyph.ucs4) {
	case 0:
		charname = "missing";
		break;
	case '&':
		charname = "&amp;";
		break;
	case '\'':
		charname = "&apos;";
		break;
	case '"':
	case '<':
	case '>':
		charname = sprintf("&#x%x;", glyph.ucs4);
		break;
	default:
		if (' ' <= glyph.ucs4 && glyph.ucs4 <= '~')
			charname = sprintf("%c", glyph.ucs4);
		else
			charname = sprintf("&#x%x;", glyph.ucs4);
		break;
	}
	if (glyph.ucs4 == 0)
		File::fprintf(f, "<missing-glyph");
	else {
		File::fprintf(f, "<glyph unicode=\"%s\"", charname);
		if (hash_test(svg_names, glyph.ucs4))
			File::fprintf(f, " glyph-name=\"%s\"", svg_names[glyph.ucs4]);
	}
	File::fprintf(f, " horiz-adv-x=\"%f\"", svg_value(metrics.width));

	bool first = true;

	void svg_coord(real x, real y)
	{
		File::fprintf(f, "%f,%f", svg_value(x), svg_value(-y));
	}

	void svg_cmd(string cmd)
	{
		if (first)
			File::fprintf(f, " d=\"");
		File::fprintf(f, "%s", cmd);
		first = false;
	}

	void svg_move (real x, real y)
	{
		svg_cmd("M");
		svg_coord(x, y);
	}

	void svg_line (real x, real y)
	{
		svg_cmd("L");
		svg_coord(x, y);
	}

	void svg_curve(real x1, real y1, real x2, real y2, real x3, real y3)
	{
		svg_cmd("C");
		svg_coord(x1, y1);
		File::fprintf(f, ",");
		svg_coord(x2, y2);
		File::fprintf(f, ",");
		svg_coord(x3, y3);
	}

	draw_calls_t svg_calls = {
		.move = svg_move,
		.line = svg_line,
		.curve = svg_curve,
	};

	glyph_path(&glyph, &svg_calls);
	if (!first)
		File::fprintf(f, "\"");
	File::fprintf(f, "/>\n");
}

void print_font_svg (file f, &font_t font)
{
	load_svg_names(glyph_list_name);

	for (int i = 0; i < dim(svg_header); i++) {
		File::fprintf(f, "%s\n", svg_header[i]);
	}

	for (int i = 0; i < dim(font.metadata); i++)
		File::fprintf(f, "%s\n", font.metadata[i]);
	File::fprintf(f, "</metadata>\n");
	File::fprintf(f, "<defs>\n");
	File::fprintf(f, "<font id=\"%s\">\n", font.name);
	File::fprintf(f, "<font-face\n");
	File::fprintf(f, "font-family=\"%s\"\n", font.name);
	File::fprintf(f, "font-style=\"%s\"\n", font.style);
	File::fprintf(f, "units-per-em=\"%f\"\n", font.units_per_em);
	File::fprintf(f, "ascent=\"%f\"\n", font.ascent);
	File::fprintf(f, "descent=\"%f\"\n", font.descent);
	File::fprintf(f, "cap-height=\"%f\"\n", font.cap_height);
	File::fprintf(f, "x-height=\"%f\"\n", font.x_height);
	File::fprintf(f, "/>\n");

	int[...] keys = hash_keys(font.glyphs);

	bool key_gt(int a, int b) { return a > b; }

	Sort::qsort(&keys, key_gt);
	for (int i = 0; i < dim(keys); i++)
		print_glyph_svg(f, &font, &(font.glyphs[keys[i]]));
	for (int i = 0; i < dim(svg_footer); i++) {
		File::fprintf(f, "%s\n", svg_footer[i]);
	}
}

string project_version = "@VERSION@";
string svg_output_name;
string stf_output_name;
bool version = false;
int user_argind;

ParseArgs::argdesc argd = {
	.args = {
		{
			.var = { .arg_flag = &version },
			.abbr = 'V',
			.name = "version",
			.desc = "Print version and exit"
		},
		{
			.var = { .arg_string = &svg_output_name },
			.abbr = 's',
			.name = "svg",
			.expr_name = "svg",
			.desc = "Target for font in SVG format"
		},
		{
			.var = { .arg_string = &stf_output_name },
			.name = "stf",
			.expr_name = "stf",
			.desc = "Target for font in STF format"
		},
		{
			.var = { .arg_string = &font_name },
			.abbr = 'f',
			.name = "font",
			.expr_name = "font",
			.desc = "Font name to draw under each glyph"
		},
		{
			.var = { .arg_real = &glyph_scale },
			.name = "scale",
			.expr_name = "scale",
			.desc = "Scale factor when reading glyphs"
		},
		{
			.var = { .arg_real = &glyph_round },
			.name = "round",
			.expr_name = "round",
			.desc = "Round coords to the nearest multiple of this"
		},
		{
			.var = { .arg_string = &glyph_list_name },
			.abbr = 'g',
			.name = "glyphlist",
			.expr_name = "glyphlist",
			.desc = "Name of glyph list file"
		},
	},
	.unknown = &user_argind
};

void main () {
	string initial_filename = "";

	ParseArgs::parseargs(&argd, &argv);

	if (version) {
		printf("%s %s\n", argv[0], project_version);
		exit(0);
	}

	if (is_uninit(&user_argind))
		user_argind = dim(argv);
	string[] rest = (string[dim(argv) - user_argind]) { [i] = argv[i+user_argind] };
	argv = rest;

	font_t font = sample_font;

	if (dim(argv) > 0) {
		initial_filename = argv[0];
		twixt(file f = File::open(initial_filename, "r"); File::close(f))
			font = read_font_stf(f);
	}

	if (!is_uninit(&svg_output_name))
	{
		twixt(file f = File::open(svg_output_name, "w"); File::close(f)) {
			print_font_svg(f, &font);
		}
		exit(0);
	}

	if (!is_uninit(&stf_output_name))
	{
		twixt(file f = File::open(stf_output_name, "w"); File::close(f)) {
			print_font_stf(f, &font);
		}
		exit(0);
	}

	&nichrome_t		nichrome = new ("Glyph Editor", 0, 0);

	&widget_t	ucs4name;
	&widget_t	infotext = Textline::new(&nichrome, 80);
	&Textline::textline_t	errortext = Textline::new(&nichrome, 80);

	errortext.color.red = 1;

	void check_ink() {
		int[...] keys = hash_keys(font.glyphs);

		bool key_gt(int a, int b) { return a > b; }

		Sort::qsort(&keys, key_gt);

		for (int i = 0; i < dim(keys); i++) {
			int key = keys[i];
			metrics_t check = measure_ink(&font.glyphs[key]);
			if (check != font.glyphs[key].metrics)
				printf("metrics for 0x%x %v != %v\n", font.glyphs[key].ucs4, font.glyphs[key].metrics, check);
		}
	}

	bool glyphed_key_callback (&widget_t widget, string key) {
		switch (key) {
		case "Tab":
			set_key_focus(&nichrome, &ucs4name);
			return true;
		case "I":
			check_ink();
			return true;
		default:
			break;
		}
		return false;
	}

	void glyphed_info_callback (&widget_t widget, string info) {
		Textline::set_text(&infotext, info);
	}

	void info(string format, args...) {
		Textline::set_text(&infotext, sprintf(format, args...));
	}

	void glyphed_error_callback (&widget_t widget, string message) {
		Textline::set_text(&errortext, message);
	}

	void error(string format, args...) {
		Textline::set_text(&errortext, sprintf(format, args...));
	}

	&Glyphed::glyphed_t	glyphed = Glyphed::new (&nichrome, &font, glyphed_key_callback, glyphed_info_callback, glyphed_error_callback);

	void exit_callback (&widget_t widget, bool state) {
		exit(0);
	}

	&widget_t	filelabel = Label::new(&nichrome, "File:");
	&widget_t	filename = Textline::new(&nichrome, 32);
	Textline::set_text(&filename, initial_filename);

	&widget_t	svgname = Textline::new(&nichrome, 32);

	void svg_callback (&widget_t widget, bool state) {
		Textline::textline_t svgline = svgname;
		Textline::textline_t textline = svgname;
		try {
			twixt(file f = File::open(textline.text, "w"); File::close(f))
				print_font_svg(f, &font);
		} catch File::open_error(string message, File::error_type type, string filename) {
			error("%s: %s", filename, message);
		}
	}

	&widget_t	svgbutton = Button::new(&nichrome, "SVG Save:", svg_callback);

	&widget_t	ucs4label = Label::new(&nichrome, "Codepoint:");
	&ucs4name = Textline::new(&nichrome, 12);
	Textline::set_text(&ucs4name, sprintf("0x%x", first_ucs4(&font)));

	bool ucs4_callback (&widget_t widget, string key) {
		&Textline::textline_t textline = &widget;
		switch (key) {
		case "Return":
			int ucs4;
			if (String::length(textline.text) == 1)
				ucs4 = textline.text[0];
			else
				ucs4 = atoi(textline.text);
			Textline::set_text(&textline, sprintf("0x%02x", ucs4));
			if (!hash_test(font.glyphs, ucs4)) {
				font.glyphs[ucs4] = font.glyphs[first_ucs4(&font)];
				font.glyphs[ucs4].ucs4 = ucs4;
				font.glyphs[ucs4].outline = (real[...]) { 'e' };
			}
			Glyphed::set_glyph(&glyphed, &font.glyphs[ucs4]);
			return true;
		case "plus":
		case "equal":
			int ucs4 = next_ucs4(&font, atoi(textline.text));
			Textline::set_text(&textline, sprintf("0x%02x", ucs4));
			Glyphed::set_glyph(&glyphed, &font.glyphs[ucs4]);
			return true;
		case "minus":
		case "underscore":
			int ucs4 = prev_ucs4(&font, atoi(textline.text));
			Textline::set_text(&textline, sprintf("0x%02x", ucs4));
			Glyphed::set_glyph(&glyphed, &font.glyphs[ucs4]);
			return true;
		case "Tab":
			set_key_focus(&nichrome, &glyphed);
			return true;
		}
		return false;
	}

	&Textline::textline_t ucs4textline = &ucs4name;
	ucs4textline.callback = ucs4_callback;

	&widget_t	exit = Button::new (&nichrome, "Exit",
					    exit_callback);

	void load_callback (&widget_t widget, bool state) {
		Textline::textline_t textline = filename;
		error("");
		try {
			twixt(file f = File::open(textline.text, "r"); File::close(f)) {
				font = read_font_stf(f);
				Glyphed::set_font(&glyphed, &font);
			}
		} catch File::open_error(string message, File::error_type type, string filename) {
			error("%s: %s", filename, message);
		}
	}

	void save_callback (&widget_t widget, bool state) {
		Textline::textline_t textline = filename;
		error("");
		try {
			twixt(file f = File::open(textline.text, "w"); File::close(f)) {
				print_font_stf(f, &font);
			}
		} catch File::open_error(string message, File::error_type type, string filename) {
			error("%s: %s", filename, message);
		}
	}


	&widget_t	load = Button::new (&nichrome, "Load",
					    load_callback);
	&widget_t	save = Button::new (&nichrome, "Save",
					    save_callback);

	&widget_t	scalelabel = Label::new(&nichrome, "Scale:");
	&Textline::textline_t scaletext = Textline::new(&nichrome, 10);

	bool scale_callback(&widget_t widget, string key) {
		error("");
		switch (key) {
		case "Return":
			real scale;
			if (File::sscanf(scaletext.text, "%f", &scale) == 1) {
				if (0.1 <= scale && scale <= 10)
					Glyphed::scale(&glyphed, scale, scale);
			} else {
				printf("sscanf failed\n");
			}
			return true;
		case "Tab":
			set_key_focus(&nichrome, &glyphed);
			return true;
		}
		return false;
	}
	scaletext.callback = scale_callback;

	bool paste_callback (&widget_t widget, string key) {
		&Textline::textline_t textline = &widget;
		switch (key) {
		case "Return":
			int ucs4;
			if (String::length(textline.text) == 1)
				ucs4 = textline.text[0];
			else
				ucs4 = atoi(textline.text);
			Textline::set_text(&textline, sprintf("0x%02x", ucs4));
			if (hash_test(font.glyphs, ucs4)) {
				Glyphed::paste(&glyphed, &font.glyphs[ucs4]);
			}
			return true;
		case "Tab":
			set_key_focus(&nichrome, &glyphed);
			return true;
		}
		return false;
	}

	&widget_t	pastelabel = Label::new(&nichrome, "Paste:");
	&Textline::textline_t pastetext = Textline::new(&nichrome, 10);

	pastetext.callback = paste_callback;

	&Box::box_t	hbox = Box::new (Box::dir_t.horizontal,
					 Box::widget_item (&load, 0),
					 Box::widget_item (&save, 0),
					 Box::widget_item (&filelabel, 0),
					 Box::widget_item (&filename, 1),
					 Box::widget_item (&ucs4label, 0),
					 Box::widget_item (&ucs4name, 1),
					 Box::widget_item (&exit, 0));

	&Box::box_t	sbox = Box::new (Box::dir_t.horizontal,
					 Box::widget_item (&scalelabel, 0),
					 Box::widget_item (&scaletext, 100, 0),
					 Box::widget_item (&pastelabel, 0),
					 Box::widget_item (&pastetext, 100, 0),
					 Box::widget_item (&svgbutton, 0, 0),
					 Box::widget_item (&svgname, 100, 0));

	&Box::box_t	vbox = Box::new (Box::dir_t.vertical,
					 Box::box_item (&hbox),
					 Box::widget_item(&infotext, 10, 0),
					 Box::widget_item(&errortext, 10, 0),
					 Box::box_item (&sbox),
					 Box::widget_item(&glyphed, 10));

	set_box (&nichrome, &vbox);
	set_key_focus(&nichrome, &glyphed);
	main_loop (&nichrome);
}

main ();
