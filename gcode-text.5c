#!/usr/bin/env nickle
/*
 * Copyright Â© 2023 Keith Packard <keithp@keithp.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
 */

const int UCS_PAGE_SHIFT = 7;
const int UCS_PER_PAGE =   (1 << UCS_PAGE_SHIFT);

/* encodes a specific Unicode page */
typedef struct {
	int			page;
	int[UCS_PER_PAGE]	offsets;
} charmap_t;

typedef struct {
	string		name;		/* font name */
	string		style;		/* font style */
	charmap_t[] 	charmap;	/* array of unicode page maps */
	int[]		outlines;	/* glyphs, including metrics and snap values */
	int		space;		/* white space between glyphs */
	int		ascent;		/* overall font ascent value */
	int		descent;	/* overall font descent value */
	int		height;		/* font line height, including leading */

	int		cur_page;	/* cache for current unicode page */
} font_t;

/*
 * Each glyph contains metrics, a list of snap coordinates and then a list of
 * drawing commands.
 *
 * The metrics contain four values:
 *
 *  0. left_side_bearing    distance from left edge of cell to left edge of glyph (+ left)
 *  1. right_side_bearing   distance from left edge of cell to right edge of glyph (+ left)
 *  2. ascent               distance from baseline to top of ink (+ up)
 *  3. descent              distance from baseline to bottom of ink (+ down)
 *
 * Yes, the ascent value has an unexpected sign, but that's how fonts
 * work elsewhere.
 *
 * The snap coordinates are in two lists, snap_x and snap_y. The
 * lengths of each list occurs first, then the two arrays
 *
 *  4. snap_n_x             number of X snap coordinates
 *  5. snap_n_y             number of Y snap coordinates
 *  6. snap_x               array of snap_n_x coordinates
 *  6 + snap_n_x. snap_y    array of snap_n_y coordinates
 *
 * The snap values aren't used in this particular implementation;
 * they're useful when rasterizing the glyphs to a pixel grid; each
 * snap coordinate should be moved to the nearest pixel value and values
 * between the snap coordinates should be interpolated to fit.
 *
 * After the snap lists, there's a list of drawing operations ending with
 * 'e':
 *
 *  'm': move (x, y)
 *  'l': draw a line (x,y)
 *  'c': draw a cubic spline (x1, y1, x2, y2, x3, y3)
 *  '2': draw a quadratic spline (x1, y1, x2, y2)
 *  'e': end of glyph
 *
 * The 'l', 'c' and '2' commands use the current position as an
 * implicit additional coordinate.
 *
 * These glyphs are drawn in a 64x64 grid
 */

const int[] outlines = {
/* 0x0 '\0'  offset 0 */
    0, 24, 42, 0, 2, 4,
    0, 24, /* snap_x */
    -42, -21, -15, 0, /* snap_y */
    'm', 0, 0,
    'l', 0, -42,
    'l', 24, -42,
    'l', 24, 0,
    'l', 0, 0,
    'e',
/* 0x20 ' '  offset 28 */
    0, 4, 0, 0, 2, 3,
    -128, 0, /* snap_x */
    -21, -15, 0, /* snap_y */
    'e',
/* 0x21 '!'  offset 40 */
    0, 4, 42, 0, 3, 3,
    0, 2, 4, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 2, -42,
    'l', 2, -14,
    'm', 2, -4,
    'c', 1, -4, 0, -3, 0, -2,
    'c', 0, -1, 1, 0, 2, 0,
    'c', 3, 0, 4, -1, 4, -2,
    'c', 4, -3, 3, -4, 2, -4,
    'e',
/* 0x22 '"'  offset 90 */
    0, 16, 42, -28, 2, 3,
    0, 16, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 0, -42,
    'l', 0, -28,
    'm', 16, -42,
    'l', 16, -28,
    'e',
/* 0x23 '#'  offset 114 */
    0, 30, 50, 14, 2, 5,
    0, 30, /* snap_x */
    -24, -21, -15, -12, 0, /* snap_y */
    'm', 16, -50,
    'l', 2, 14,
    'm', 28, -50,
    'l', 14, 14,
    'm', 2, -24,
    'l', 30, -24,
    'm', 0, -12,
    'l', 28, -12,
    'e',
/* 0x24 '$'  offset 152 */
    0, 28, 50, 8, 4, 4,
    0, 10, 18, 28, /* snap_x */
    -42, -21, -15, 0, /* snap_y */
    'm', 10, -50,
    'l', 10, 8,
    'm', 18, -50,
    'l', 18, 8,
    'm', 28, -36,
    'c', 24, -42, 18, -42, 14, -42,
    'c', 10, -42, 0, -42, 0, -34,
    'c', 0, -25, 8, -24, 14, -22,
    'c', 20, -20, 28, -19, 28, -9,
    'c', 28, 0, 18, 0, 14, 0,
    'c', 10, 0, 4, 0, 0, -6,
    'e',
/* 0x25 '%'  offset 224 */
    0, 36, 42, 0, 4, 7,
    0, 14, 22, 36, /* snap_x */
    -42, -38, -28, -21, -15, -14, 0, /* snap_y */
    'm', 36, -42,
    'l', 0, 0,
    'm', 10, -42,
    'c', 12, -41, 14, -40, 14, -36,
    'c', 14, -30, 11, -28, 6, -28,
    'c', 2, -28, 0, -30, 0, -34,
    'c', 0, -39, 3, -42, 8, -42,
    'l', 10, -42,
    'c', 18, -37, 28, -37, 36, -42,
    'm', 28, -14,
    'c', 24, -14, 22, -11, 22, -6,
    'c', 22, -2, 24, 0, 28, 0,
    'c', 33, 0, 36, -2, 36, -8,
    'c', 36, -12, 34, -14, 30, -14,
    'l', 28, -14,
    'e',
/* 0x26 '&'  offset 323 */
    0, 40, 42, 0, 4, 4,
    0, 10, 22, 40, /* snap_x */
    -28, -21, -15, 0, /* snap_y */
    'm', 40, -24,
    'c', 40, -27, 39, -28, 37, -28,
    'c', 29, -28, 32, 0, 12, 0,
    'c', 0, 0, 0, -8, 0, -10,
    'c', 0, -24, 22, -20, 22, -34,
    'c', 22, -45, 10, -45, 10, -34,
    'c', 10, -27, 25, 0, 36, 0,
    'c', 39, 0, 40, -1, 40, -4,
    'e',
/* 0x27 '''  offset 390 */
    0, 4, 42, -30, 2, 3,
    0, 4, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 2, -38,
    'c', -1, -38, -1, -42, 2, -42,
    'c', 6, -42, 5, -33, 0, -30,
    'e',
/* 0x28 '('  offset 419 */
    0, 14, 50, 14, 2, 3,
    0, 14, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 14, -50,
    'c', -5, -32, -5, -5, 14, 14,
    'e',
/* 0x29 ')'  offset 441 */
    0, 14, 50, 14, 2, 3,
    0, 14, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 0, -50,
    'c', 19, -34, 19, -2, 0, 14,
    'e',
/* 0x2a '*'  offset 463 */
    0, 20, 30, -6, 3, 3,
    0, 10, 20, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 10, -30,
    'l', 10, -6,
    'm', 0, -24,
    'l', 20, -12,
    'm', 20, -24,
    'l', 0, -12,
    'e',
/* 0x2b '+'  offset 494 */
    0, 36, 36, 0, 3, 4,
    0, 18, 36, /* snap_x */
    -21, -18, -15, 0, /* snap_y */
    'm', 18, -36,
    'l', 18, 0,
    'm', 0, -18,
    'l', 36, -18,
    'e',
/* 0x2c ','  offset 520 */
    0, 4, 4, 8, 2, 3,
    0, 4, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 4, -2,
    'c', 4, 1, 0, 1, 0, -2,
    'c', 0, -5, 4, -5, 4, -2,
    'c', 4, 4, 2, 6, 0, 8,
    'e',
/* 0x2d '-'  offset 556 */
    0, 36, 18, -18, 2, 4,
    0, 36, /* snap_x */
    -21, -18, -15, 0, /* snap_y */
    'm', 0, -18,
    'l', 36, -18,
    'e',
/* 0x2e '.'  offset 575 */
    0, 4, 4, 0, 2, 3,
    0, 4, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 2, -4,
    'c', -1, -4, -1, 0, 2, 0,
    'c', 5, 0, 5, -4, 2, -4,
    'e',
/* 0x2f '/'  offset 604 */
    0, 36, 50, 14, 2, 3,
    0, 36, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 36, -50,
    'l', 0, 14,
    'e',
/* 0x30 '0'  offset 622 */
    0, 28, 42, 0, 2, 4,
    0, 28, /* snap_x */
    -42, -21, -15, 0, /* snap_y */
    'm', 14, -42,
    'c', 9, -42, 0, -42, 0, -21,
    'c', 0, 0, 9, 0, 14, 0,
    'c', 19, 0, 28, 0, 28, -21,
    'c', 28, -42, 19, -42, 14, -42,
    'e',
/* 0x31 '1'  offset 666 */
    0, 28, 42, 0, 2, 3,
    0, 17, 28 /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 7, -34,
    'c', 11, -35, 15, -38, 17, -42,
    'l', 17, 0,
    'e',
/* 0x32 '2'  offset 691 */
    0, 28, 42, 0, 4, 4,
    0, 2, 26, 28, /* snap_x */
    -42, -21, -15, 0, /* snap_y */
    'm', 2, -32,
    'c', 2, -34, 2, -42, 14, -42,
    'c', 26, -42, 26, -34, 26, -32,
    'c', 26, -30, 25, -25, 10, -10,
    'l', 0, 0,
    'l', 28, 0,
    'e',
/* 0x33 '3'  offset 736 */
    0, 28, 42, 0, 2, 5,
    0, 28, /* snap_x */
    -42, -26, -21, -15, 0, /* snap_y */
    'm', 4, -42,
    'l', 26, -42,
    'l', 14, -26,
    'c', 21, -26, 28, -26, 28, -14,
    'c', 28, 0, 17, 0, 13, 0,
    'c', 8, 0, 3, -1, 0, -8,
    'e',
/* 0x34 '4'  offset 780 */
    0, 28, 42, 0, 3, 4,
    0, 20, 30, /* snap_x */
    -21, -15, -14, 0, /* snap_y */
    'm', 20, -42,
    'l', 0, -14,
    'l', 30, -14,
    'm', 20, -42,
    'l', 20, 0,
    'e',
/* 0x35 '5'  offset 809 */
    0, 28, 42, 0, 2, 5,
    0, 28, /* snap_x */
    -42, -28, -21, -15, 0, /* snap_y */
    'm', 24, -42,
    'l', 4, -42,
    'l', 2, -24,
    'c', 5, -27, 10, -28, 13, -28,
    'c', 16, -28, 28, -28, 28, -14,
    'c', 28, 0, 16, 0, 13, 0,
    'c', 10, 0, 3, 0, 0, -8,
    'e',
/* 0x36 '6'  offset 860 */
    0, 28, 42, 0, 2, 5,
    0, 26, /* snap_x */
    -42, -26, -21, -15, 0, /* snap_y */
    'm', 24, -36,
    'c', 22, -41, 19, -42, 14, -42,
    'c', 9, -42, 0, -41, 0, -19,
    'c', 0, -1, 9, 0, 13, 0,
    'c', 18, 0, 26, -3, 26, -13,
    'c', 26, -18, 23, -26, 13, -26,
    'c', 10, -26, 1, -24, 0, -14,
    'e',
/* 0x37 '7'  offset 919 */
    0, 28, 42, 0, 2, 4,
    0, 28, /* snap_x */
    -42, -21, -15, 0, /* snap_y */
    'm', 28, -42,
    'l', 8, 0,
    'm', 0, -42,
    'l', 28, -42,
    'e',
/* 0x38 '8'  offset 944 */
    0, 28, 42, 0, 4, 4,
    0, 2, 26, 28, /* snap_x */
    -42, -21, -15, 0, /* snap_y */
    'm', 14, -42,
    'c', 5, -42, 2, -40, 2, -34,
    'c', 2, -18, 28, -32, 28, -11,
    'c', 28, 0, 18, 0, 14, 0,
    'c', 10, 0, 0, 0, 0, -11,
    'c', 0, -32, 26, -18, 26, -34,
    'c', 26, -40, 23, -42, 14, -42,
    'e',
/* 0x39 '9'  offset 1004 */
    0, 28, 42, 0, 2, 5,
    0, 26, /* snap_x */
    -42, -21, -16, -15, 0, /* snap_y */
    'm', 26, -28,
    'c', 25, -16, 13, -16, 13, -16,
    'c', 8, -16, 0, -19, 0, -29,
    'c', 0, -34, 3, -42, 13, -42,
    'c', 24, -42, 26, -32, 26, -23,
    'c', 26, -14, 24, 0, 12, 0,
    'c', 7, 0, 4, -2, 2, -6,
    'e',
/* 0x3a ':'  offset 1063 */
    0, 4, 28, 0, 2, 3,
    0, 4, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 2, -28,
    'c', -1, -28, -1, -24, 2, -24,
    'c', 5, -24, 5, -28, 2, -28,
    'm', 2, -4,
    'c', -1, -4, -1, 0, 2, 0,
    'c', 5, 0, 5, -4, 2, -4,
    'e',
/* 0x3b ';'  offset 1109 */
    0, 4, 28, 8, 2, 3,
    0, 4, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 2, -28,
    'c', -1, -28, -1, -24, 2, -24,
    'c', 5, -24, 5, -28, 2, -28,
    'm', 4, -2,
    'c', 4, 1, 0, 1, 0, -2,
    'c', 0, -5, 4, -5, 4, -2,
    'c', 4, 3, 2, 6, 0, 8,
    'e',
/* 0x3c '<'  offset 1162 */
    0, 32, 36, 0, 2, 3,
    0, 32, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 32, -36,
    'l', 0, -18,
    'l', 32, 0,
    'e',
/* 0x3d '='  offset 1183 */
    0, 36, 24, -12, 2, 5,
    0, 36, /* snap_x */
    -24, -21, -15, -12, 0, /* snap_y */
    'm', 0, -24,
    'l', 36, -24,
    'm', 0, -12,
    'l', 36, -12,
    'e',
/* 0x3e '>'  offset 1209 */
    0, 32, 36, 0, 2, 3,
    0, 32, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 0, -36,
    'l', 32, -18,
    'l', 0, 0,
    'e',
/* 0x3f '?'  offset 1230 */
    0, 24, 42, 0, 3, 4,
    0, 12, 24, /* snap_x */
    -42, -21, -15, 0, /* snap_y */
    'm', 0, -32,
    'c', 0, -34, 0, -42, 12, -42,
    'c', 24, -42, 24, -34, 24, -32,
    'c', 24, -29, 24, -24, 12, -20,
    'l', 12, -14,
    'm', 12, -4,
    'c', 9, -4, 9, 0, 12, 0,
    'c', 15, 0, 15, -4, 12, -4,
    'e',
/* 0x40 '@'  offset 1288 */
    0, 42, 42, 0, 1, 6,
    30, /* snap_x */
    -42, -32, -21, -15, -10, 0, /* snap_y */
    'm', 30, -26,
    'c', 28, -31, 24, -32, 21, -32,
    'c', 10, -32, 10, -23, 10, -19,
    'c', 10, -13, 11, -10, 19, -10,
    'c', 30, -10, 28, -21, 30, -32,
    'c', 27, -10, 30, -10, 34, -10,
    'c', 41, -10, 42, -19, 42, -22,
    'c', 42, -34, 34, -42, 21, -42,
    'c', 9, -42, 0, -34, 0, -21,
    'c', 0, -9, 8, 0, 21, 0,
    'c', 30, 0, 34, -3, 36, -6,
    'e',
/* 0x41 'A'  offset 1375 */
    0, 32, 42, 0, 2, 4,
    0, 32, /* snap_x */
    -21, -15, -14, 0, /* snap_y */
    'm', 16, -42,
    'l', 0, 0,
    'm', 16, -42,
    'l', 32, 0,
    'm', 6, -14,
    'l', 26, -14,
    'e',
/* 0x42 'B'  offset 1406 */
    0, 28, 42, 0, 2, 5,
    0, 28, /* snap_x */
    -42, -22, -21, -15, 0, /* snap_y */
    'm', 0, -42,
    'l', 0, 0,
    'm', 0, -42,
    'l', 18, -42,
    'c', 32, -42, 32, -22, 18, -22,
    'm', 0, -22,
    'l', 18, -22,
    'c', 32, -22, 32, 0, 18, 0,
    'l', 0, 0,
    'e',
/* 0x43 'C'  offset 1455 */
    0, 30, 42, 0, 2, 4,
    0, 30, /* snap_x */
    -42, -21, -15, 0, /* snap_y */
    'm', 30, -32,
    'c', 26, -42, 21, -42, 16, -42,
    'c', 2, -42, 0, -29, 0, -21,
    'c', 0, -13, 2, 0, 16, 0,
    'c', 21, 0, 26, 0, 30, -10,
    'e',
/* 0x44 'D'  offset 1499 */
    0, 28, 42, 0, 2, 4,
    0, 28, /* snap_x */
    -42, -21, -15, 0, /* snap_y */
    'm', 0, -42,
    'l', 0, 0,
    'm', 0, -42,
    'l', 14, -42,
    'c', 33, -42, 33, 0, 14, 0,
    'l', 0, 0,
    'e',
/* 0x45 'E'  offset 1534 */
    0, 26, 42, 0, 2, 5,
    0, 26, /* snap_x */
    -42, -22, -21, -15, 0, /* snap_y */
    'm', 0, -42,
    'l', 0, 0,
    'm', 0, -42,
    'l', 26, -42,
    'm', 0, -22,
    'l', 16, -22,
    'm', 0, 0,
    'l', 26, 0,
    'e',
/* 0x46 'F'  offset 1572 */
    0, 26, 42, 0, 2, 5,
    0, 26, /* snap_x */
    -42, -22, -21, -15, 0, /* snap_y */
    'm', 0, -42,
    'l', 0, 0,
    'm', 0, -42,
    'l', 26, -42,
    'm', 0, -22,
    'l', 16, -22,
    'e',
/* 0x47 'G'  offset 1604 */
    0, 30, 42, 0, 2, 5,
    0, 30, /* snap_x */
    -42, -21, -16, -15, 0, /* snap_y */
    'm', 30, -32,
    'c', 26, -42, 21, -42, 16, -42,
    'c', 2, -42, 0, -29, 0, -21,
    'c', 0, -13, 2, 0, 16, 0,
    'c', 28, 0, 30, -7, 30, -16,
    'm', 20, -16,
    'l', 30, -16,
    'e',
/* 0x48 'H'  offset 1655 */
    0, 28, 42, 0, 2, 4,
    0, 28, /* snap_x */
    -22, -21, -15, 0, /* snap_y */
    'm', 0, -42,
    'l', 0, 0,
    'm', 28, -42,
    'l', 28, 0,
    'm', 0, -22,
    'l', 28, -22,
    'e',
/* 0x49 'I'  offset 1686 */
    0, 0, 42, 0, 1, 3,
    0, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 0, -42,
    'l', 0, 0,
    'e',
/* 0x4a 'J'  offset 1703 */
    0, 20, 42, 0, 2, 3,
    0, 20, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 20, -42,
    'l', 20, -10,
    'c', 20, 3, 0, 3, 0, -10,
    'l', 0, -14,
    'e',
/* 0x4b 'K'  offset 1731 */
    0, 28, 42, 0, 2, 3,
    0, 28, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 0, -42,
    'l', 0, 0,
    'm', 28, -42,
    'l', 0, -14,
    'm', 10, -24,
    'l', 28, 0,
    'e',
/* 0x4c 'L'  offset 1761 */
    0, 24, 42, 0, 2, 3,
    0, 24, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 0, -42,
    'l', 0, 0,
    'm', 0, 0,
    'l', 24, 0,
    'e',
/* 0x4d 'M'  offset 1785 */
    0, 32, 42, 0, 2, 3,
    0, 32, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 0, -42,
    'l', 0, 0,
    'm', 0, -42,
    'l', 16, 0,
    'm', 32, -42,
    'l', 16, 0,
    'm', 32, -42,
    'l', 32, 0,
    'e',
/* 0x4e 'N'  offset 1821 */
    0, 28, 42, 0, 2, 3,
    0, 28, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 0, -42,
    'l', 0, 0,
    'm', 0, -42,
    'l', 28, 0,
    'm', 28, -42,
    'l', 28, 0,
    'e',
/* 0x4f 'O'  offset 1851 */
    0, 32, 42, 0, 2, 4,
    0, 32, /* snap_x */
    -42, -21, -15, 0, /* snap_y */
    'm', 16, -42,
    'c', 2, -42, 0, -29, 0, -21,
    'c', 0, -13, 2, 0, 16, 0,
    'c', 30, 0, 32, -13, 32, -21,
    'c', 32, -29, 30, -42, 16, -42,
    'e',
/* 0x50 'P'  offset 1895 */
    0, 28, 42, 0, 2, 5,
    0, 28, /* snap_x */
    -42, -21, -20, -15, 0, /* snap_y */
    'm', 0, -42,
    'l', 0, 0,
    'm', 0, -42,
    'l', 18, -42,
    'c', 32, -42, 32, -20, 18, -20,
    'l', 0, -20,
    'e',
/* 0x51 'Q'  offset 1931 */
    0, 32, 42, 4, 2, 4,
    0, 32, /* snap_x */
    -42, -21, -15, 0, /* snap_y */
    'm', 16, -42,
    'c', 2, -42, 0, -29, 0, -21,
    'c', 0, -13, 2, 0, 16, 0,
    'c', 30, 0, 32, -13, 32, -21,
    'c', 32, -29, 30, -42, 16, -42,
    'm', 18, -8,
    'l', 30, 4,
    'e',
/* 0x52 'R'  offset 1981 */
    0, 28, 42, 0, 2, 5,
    0, 28, /* snap_x */
    -42, -22, -21, -15, 0, /* snap_y */
    'm', 0, -42,
    'l', 0, 0,
    'm', 0, -42,
    'l', 18, -42,
    'c', 32, -42, 31, -22, 18, -22,
    'l', 0, -22,
    'm', 14, -22,
    'l', 28, 0,
    'e',
/* 0x53 'S'  offset 2023 */
    0, 28, 42, 0, 2, 4,
    0, 28, /* snap_x */
    -42, -21, -15, 0, /* snap_y */
    'm', 28, -36,
    'c', 25, -41, 21, -42, 14, -42,
    'c', 10, -42, 0, -42, 0, -34,
    'c', 0, -17, 28, -28, 28, -9,
    'c', 28, 0, 19, 0, 14, 0,
    'c', 7, 0, 3, -1, 0, -6,
    'e',
/* 0x54 'T'  offset 2074 */
    0, 28, 42, 0, 3, 4,
    0, 14, 28, /* snap_x */
    -42, -21, -15, 0, /* snap_y */
    'm', 14, -42,
    'l', 14, 0,
    'm', 0, -42,
    'l', 28, -42,
    'e',
/* 0x55 'U'  offset 2100 */
    0, 28, 42, 0, 2, 3,
    0, 28, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 0, -42,
    'l', 0, -12,
    'c', 0, 4, 28, 4, 28, -12,
    'l', 28, -42,
    'e',
/* 0x56 'V'  offset 2128 */
    0, 32, 42, 0, 2, 3,
    0, 32, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 0, -42,
    'l', 16, 0,
    'm', 32, -42,
    'l', 16, 0,
    'e',
/* 0x57 'W'  offset 2152 */
    0, 40, 42, 0, 2, 3,
    0, 40, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 0, -42,
    'l', 10, 0,
    'm', 20, -42,
    'l', 10, 0,
    'm', 20, -42,
    'l', 30, 0,
    'm', 40, -42,
    'l', 30, 0,
    'e',
/* 0x58 'X'  offset 2188 */
    0, 28, 42, 0, 2, 3,
    0, 28, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 0, -42,
    'l', 28, 0,
    'm', 28, -42,
    'l', 0, 0,
    'e',
/* 0x59 'Y'  offset 2212 */
    0, 32, 42, 0, 3, 3,
    0, 16, 32, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 0, -42,
    'l', 16, -22,
    'l', 16, 0,
    'm', 32, -42,
    'l', 16, -22,
    'e',
/* 0x5a 'Z'  offset 2240 */
    0, 28, 42, 0, 2, 4,
    0, 28, /* snap_x */
    -42, -21, -15, 0, /* snap_y */
    'm', 28, -42,
    'l', 0, 0,
    'm', 0, -42,
    'l', 28, -42,
    'm', 0, 0,
    'l', 28, 0,
    'e',
/* 0x5b '['  offset 2271 */
    0, 14, 44, 0, 2, 4,
    0, 14, /* snap_x */
    -44, -21, -15, 0, /* snap_y */
    'm', 14, -44,
    'l', 0, -44,
    'l', 0, 0,
    'l', 14, 0,
    'e',
/* 0x5c '\'  offset 2296 */
    0, 36, 50, 14, 2, 3,
    0, 36, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 0, -50,
    'l', 36, 14,
    'e',
/* 0x5d ']'  offset 2314 */
    0, 14, 44, 0, 2, 4,
    0, 14, /* snap_x */
    -44, -21, -15, 0, /* snap_y */
    'm', 0, -44,
    'l', 14, -44,
    'l', 14, 0,
    'l', 0, 0,
    'e',
/* 0x5e '^'  offset 2339 */
    0, 32, 46, -18, 2, 3,
    0, 32, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 16, -46,
    'l', 0, -18,
    'm', 16, -46,
    'l', 32, -18,
    'e',
/* 0x5f '_'  offset 2363 */
    0, 36, 0, 0, 2, 3,
    0, 36, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 0, 0,
    'l', 36, 0,
    'e',
/* 0x60 '`'  offset 2381 */
    0, 4, 42, -30, 2, 3,
    0, 4, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 4, -42,
    'c', 2, -40, 0, -39, 0, -32,
    'c', 0, -31, 1, -30, 2, -30,
    'c', 5, -30, 5, -34, 2, -34,
    'e',
/* 0x61 'a'  offset 2417 */
    0, 24, 28, 0, 2, 4,
    0, 24, /* snap_x */
    -28, -21, -15, 0, /* snap_y */
    'm', 24, -28,
    'l', 24, 0,
    'm', 24, -22,
    'c', 21, -27, 18, -28, 13, -28,
    'c', 2, -28, 0, -19, 0, -14,
    'c', 0, -9, 2, 0, 13, 0,
    'c', 18, 0, 21, -1, 24, -6,
    'e',
/* 0x62 'b'  offset 2467 */
    0, 24, 42, 0, 2, 4,
    0, 24, /* snap_x */
    -28, -21, -15, 0, /* snap_y */
    'm', 0, -42,
    'l', 0, 0,
    'm', 0, -22,
    'c', 3, -26, 6, -28, 11, -28,
    'c', 22, -28, 24, -19, 24, -14,
    'c', 24, -9, 22, 0, 11, 0,
    'c', 6, 0, 3, -2, 0, -6,
    'e',
/* 0x63 'c'  offset 2517 */
    0, 24, 28, 0, 2, 4,
    0, 24, /* snap_x */
    -28, -21, -15, 0, /* snap_y */
    'm', 24, -22,
    'c', 21, -26, 18, -28, 13, -28,
    'c', 2, -28, 0, -19, 0, -14,
    'c', 0, -9, 2, 0, 13, 0,
    'c', 18, 0, 21, -2, 24, -6,
    'e',
/* 0x64 'd'  offset 2561 */
    0, 24, 42, 0, 2, 4,
    0, 24, /* snap_x */
    -28, -21, -15, 0, /* snap_y */
    'm', 24, -42,
    'l', 24, 0,
    'm', 24, -22,
    'c', 21, -26, 18, -28, 13, -28,
    'c', 2, -28, 0, -19, 0, -14,
    'c', 0, -9, 2, 0, 13, 0,
    'c', 18, 0, 21, -2, 24, -6,
    'e',
/* 0x65 'e'  offset 2611 */
    0, 24, 28, 0, 2, 5,
    0, 24, /* snap_x */
    -28, -21, -16, -15, 0, /* snap_y */
    'm', 0, -16,
    'l', 24, -16,
    'c', 24, -20, 24, -28, 13, -28,
    'c', 2, -28, 0, -19, 0, -14,
    'c', 0, -9, 2, 0, 13, 0,
    'c', 18, 0, 21, -2, 24, -6,
    'e',
/* 0x66 'f'  offset 2659 */
    0, 16, 42, 0, 3, 5,
    0, 6, 16, /* snap_x */
    -42, -28, -21, -15, 0, /* snap_y */
    'm', 16, -42,
    'c', 8, -42, 6, -40, 6, -34,
    'l', 6, 0,
    'm', 0, -28,
    'l', 14, -28,
    'e',
/* 0x67 'g'  offset 2693 */
    0, 24, 28, 14, 2, 5,
    0, 24, /* snap_x */
    -28, -21, -15, 0, 14, /* snap_y */
    'm', 24, -28,
    'l', 24, 4,
    'c', 23, 14, 16, 14, 13, 14,
    'c', 10, 14, 8, 14, 6, 12,
    'm', 24, -22,
    'c', 21, -26, 18, -28, 13, -28,
    'c', 2, -28, 0, -19, 0, -14,
    'c', 0, -9, 2, 0, 13, 0,
    'c', 18, 0, 21, -2, 24, -6,
    'e',
/* 0x68 'h'  offset 2758 */
    0, 22, 42, 0, 2, 4,
    0, 22, /* snap_x */
    -28, -21, -15, 0, /* snap_y */
    'm', 0, -42,
    'l', 0, 0,
    'm', 0, -20,
    'c', 8, -32, 22, -31, 22, -20,
    'l', 22, 0,
    'e',
/* 0x69 'i'  offset 2790 */
    0, 4, 44, 0, 3, 3,
    0, 2, 4, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 0, -42,
    'c', 0, -39, 4, -39, 4, -42,
    'c', 4, -45, 0, -45, 0, -42,
    'm', 2, -28,
    'l', 2, 0,
    'e',
/* 0x6a 'j'  offset 2826 */
    -8, 4, 44, 14, 3, 4,
    0, 2, 4, /* snap_x */
    -21, -15, 0, 14, /* snap_y */
    'm', 0, -42,
    'c', 0, -39, 4, -39, 4, -42,
    'c', 4, -45, 0, -45, 0, -42,
    'm', 2, -28,
    'l', 2, 6,
    'c', 2, 13, -1, 14, -8, 14,
    'e',
/* 0x6b 'k'  offset 2870 */
    0, 22, 42, 0, 2, 3,
    0, 22, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 0, -42,
    'l', 0, 0,
    'm', 20, -28,
    'l', 0, -8,
    'm', 8, -16,
    'l', 22, 0,
    'e',
/* 0x6c 'l'  offset 2900 */
    0, 0, 42, 0, 1, 3,
    0, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 0, -42,
    'l', 0, 0,
    'e',
/* 0x6d 'm'  offset 2917 */
    0, 44, 28, 0, 3, 4,
    0, 22, 44, /* snap_x */
    -28, -21, -15, 0, /* snap_y */
    'm', 0, -28,
    'l', 0, 0,
    'm', 0, -20,
    'c', 5, -29, 22, -33, 22, -20,
    'l', 22, 0,
    'm', 22, -20,
    'c', 27, -29, 44, -33, 44, -20,
    'l', 44, 0,
    'e',
/* 0x6e 'n'  offset 2963 */
    0, 22, 28, 0, 2, 4,
    0, 22, /* snap_x */
    -28, -21, -15, 0, /* snap_y */
    'm', 0, -28,
    'l', 0, 0,
    'm', 0, -20,
    'c', 4, -28, 22, -34, 22, -20,
    'l', 22, 0,
    'e',
/* 0x6f 'o'  offset 2995 */
    0, 26, 28, 0, 2, 4,
    0, 26, /* snap_x */
    -28, -21, -15, 0, /* snap_y */
    'm', 13, -28,
    'c', 2, -28, 0, -19, 0, -14,
    'c', 0, -9, 2, 0, 13, 0,
    'c', 24, 0, 26, -9, 26, -14,
    'c', 26, -19, 24, -28, 13, -28,
    'e',
/* 0x70 'p'  offset 3039 */
    0, 24, 28, 14, 2, 4,
    0, 24, /* snap_x */
    -28, -21, -15, 0, /* snap_y */
    'm', 0, -28,
    'l', 0, 14,
    'm', 0, -22,
    'c', 3, -26, 6, -28, 11, -28,
    'c', 22, -28, 24, -19, 24, -14,
    'c', 24, -9, 22, 0, 11, 0,
    'c', 6, 0, 3, -2, 0, -6,
    'e',
/* 0x71 'q'  offset 3089 */
    0, 24, 28, 14, 2, 4,
    0, 24, /* snap_x */
    -28, -21, -15, 0, /* snap_y */
    'm', 24, -28,
    'l', 24, 14,
    'm', 24, -22,
    'c', 21, -26, 18, -28, 13, -28,
    'c', 2, -28, 0, -19, 0, -14,
    'c', 0, -9, 2, 0, 13, 0,
    'c', 18, 0, 21, -2, 24, -6,
    'e',
/* 0x72 'r'  offset 3139 */
    0, 16, 28, 0, 2, 4,
    0, 16, /* snap_x */
    -28, -21, -15, 0, /* snap_y */
    'm', 0, -28,
    'l', 0, 0,
    'm', 0, -16,
    'c', 2, -27, 7, -28, 16, -28,
    'e',
/* 0x73 's'  offset 3168 */
    0, 22, 28, 0, 2, 4,
    0, 22, /* snap_x */
    -28, -21, -15, 0, /* snap_y */
    'm', 22, -22,
    'c', 22, -27, 16, -28, 11, -28,
    'c', 4, -28, 0, -26, 0, -22,
    'c', 0, -11, 22, -20, 22, -7,
    'c', 22, 0, 17, 0, 11, 0,
    'c', 6, 0, 0, -1, 0, -6,
    'e',
/* 0x74 't'  offset 3219 */
    0, 16, 42, 0, 3, 4,
    0, 6, 16, /* snap_x */
    -28, -21, -15, 0, /* snap_y */
    'm', 6, -42,
    'l', 6, -8,
    'c', 6, -2, 8, 0, 16, 0,
    'm', 0, -28,
    'l', 14, -28,
    'e',
/* 0x75 'u'  offset 3252 */
    0, 22, 28, 0, 2, 3,
    0, 22, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 0, -28,
    'l', 0, -8,
    'c', 0, 6, 18, 0, 22, -8,
    'm', 22, -28,
    'l', 22, 0,
    'e',
/* 0x76 'v'  offset 3283 */
    0, 24, 28, 0, 2, 3,
    0, 24, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 0, -28,
    'l', 12, 0,
    'm', 24, -28,
    'l', 12, 0,
    'e',
/* 0x77 'w'  offset 3307 */
    0, 32, 28, 0, 2, 3,
    0, 32, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 0, -28,
    'l', 8, 0,
    'm', 16, -28,
    'l', 8, 0,
    'm', 16, -28,
    'l', 24, 0,
    'm', 32, -28,
    'l', 24, 0,
    'e',
/* 0x78 'x'  offset 3343 */
    0, 22, 28, 0, 2, 3,
    0, 22, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 0, -28,
    'l', 22, 0,
    'm', 22, -28,
    'l', 0, 0,
    'e',
/* 0x79 'y'  offset 3367 */
    -2, 24, 28, 14, 2, 4,
    0, 24, /* snap_x */
    -21, -15, 0, 14, /* snap_y */
    'm', 0, -28,
    'l', 12, 0,
    'm', 24, -28,
    'l', 12, 0,
    'c', 6, 13, 0, 14, -2, 14,
    'e',
/* 0x7a 'z'  offset 3399 */
    0, 22, 28, 0, 2, 4,
    0, 22, /* snap_x */
    -28, -21, -15, 0, /* snap_y */
    'm', 22, -28,
    'l', 0, 0,
    'm', 0, -28,
    'l', 22, -28,
    'm', 0, 0,
    'l', 22, 0,
    'e',
/* 0x7b '{'  offset 3430 */
    0, 16, 44, 0, 3, 5,
    0, 6, 16, /* snap_x */
    -44, -24, -21, -15, 0, /* snap_y */
    'm', 16, -44,
    'c', 10, -44, 6, -42, 6, -36,
    'l', 6, -24,
    'l', 0, -24,
    'l', 6, -24,
    'l', 6, -8,
    'c', 6, -2, 10, 0, 16, 0,
    'e',
/* 0x7c '|'  offset 3474 */
    0, 0, 50, 14, 1, 3,
    0, /* snap_x */
    -21, -15, 0, /* snap_y */
    'm', 0, -50,
    'l', 0, 14,
    'e',
/* 0x7d '}'  offset 3491 */
    0, 16, 44, 0, 3, 5,
    0, 10, 16, /* snap_x */
    -44, -24, -21, -15, 0, /* snap_y */
    'm', 0, -44,
    'c', 6, -44, 10, -42, 10, -36,
    'l', 10, -24,
    'l', 16, -24,
    'l', 10, -24,
    'l', 10, -8,
    'c', 10, -2, 6, 0, 0, 0,
    'e',
/* 0x7e '~'  offset 3535 */
    0, 36, 24, -12, 2, 5,
    0, 36, /* snap_x */
    -24, -21, -15, -12, 0, /* snap_y */
    'm', 0, -14,
    'c', 1, -21, 4, -24, 8, -24,
    'c', 18, -24, 18, -12, 28, -12,
    'c', 32, -12, 35, -15, 36, -22,
    'e',
};

const charmap_t[] charmap = {
    {
	    .page = 0x0000,
	    .offsets = (int[]) {
		    0,    0,    0,    0,    0,    0,    0,    0,
		    0,    0,    0,    0,    0,    0,    0,    0,
		    0,    0,    0,    0,    0,    0,    0,    0,
		    0,    0,    0,    0,    0,    0,    0,    0,
		    28,   40,   90,  114,  152,  224,  323,  390,
		    419,  441,  463,  494,  520,  556,  575,  604,
		    622,  666,  691,  736,  780,  809,  860,  919,
		    944, 1004, 1063, 1109, 1162, 1183, 1209, 1230,
		    1288, 1375, 1406, 1455, 1499, 1534, 1572, 1604,
		    1655, 1686, 1703, 1731, 1761, 1785, 1821, 1851,
		    1895, 1931, 1981, 2023, 2074, 2100, 2128, 2152,
		    2188, 2212, 2240, 2271, 2296, 2314, 2339, 2363,
		    2381, 2417, 2467, 2517, 2561, 2611, 2659, 2693,
		    2758, 2790, 2826, 2870, 2900, 2917, 2963, 2995,
		    3039, 3089, 3139, 3168, 3219, 3252, 3283, 3307,
		    3343, 3367, 3399, 3430, 3474, 3491, 3535,    0,
	    }
    },
};

font_t font = {
	.name		= "Default",
	.style		= "Roman",
	.charmap	= charmap,
	.outlines	= outlines,
	.space		= 12,
	.ascent		= 50,
	.descent	= 14,
	.height		= 72,

	.cur_page	= 0,
};

/* Extract the unicode page number from a ucs4 value */
int ucs_page (int ucs4)
{
	return ucs4 >> UCS_PAGE_SHIFT;
}

/* Extract the ucs4 index within a page */
int ucs_char_in_page (int ucs4)
{
	return ucs4 & (UCS_PER_PAGE - 1);
}

/*
 * Find the page mapping within the font for the
 * specified page. If none is found, use page 0
 * and return false so that glyph_offset returns
 * the default glyph (0).
 */
bool find_ucs4_page(*font_t font, int page)
{
	int i;

	if (font->charmap[font->cur_page].page == page)
		return true;

	for (i = 0; i < dim(font->charmap); i++)
		if (font->charmap[i].page == page)
		{
			font->cur_page = i;
			return true;
		}

	font->cur_page = 0;
	return false;
}

/*
 * Map a UCS4 value to the index of the start of the glyph within the
 * glyph array
 */
int glyph_offset (*font_t font, int ucs4)
{
	int		idx = ucs_char_in_page(ucs4);

	if (!find_ucs4_page(font, ucs_page(ucs4)))
		idx = 0;

	return font->charmap[font->cur_page].offsets[idx];
}


/* Helper functions to extract data from the glyph array */
int glyph_left(*font_t font, int offset) = font->outlines[offset + 0];
int glyph_right(*font_t font, int offset) = font->outlines[offset + 1];
int glyph_ascent(*font_t font, int offset) = font->outlines[offset + 2];
int glyph_descent(*font_t font, int offset) = font->outlines[offset + 3];
int glyph_n_snap_x(*font_t font, int offset) = font->outlines[offset + 4];
int glyph_n_snap_y(*font_t font, int offset) = font->outlines[offset + 5];
int glyph_snap_x(*font_t font, int offset, int s) = font->outlines[offset + 6 + s];
int glyph_snap_y(*font_t font, int offset, int s) = font->outlines[offset + 6 + glyph_n_snap_x(font, offset) + s];
int glyph_draw(*font_t font, int offset) {
	return offset + 6 + glyph_n_snap_x(font, offset) + glyph_n_snap_y(font, offset);
}

/*
 * Our glyphs don't have a separate width value, instead the
 * width is "always" the right_side_bearing plus a fixed padding
 * value (font->space)
 */
real glyph_width(*font_t font, int offset) = glyph_right(font, offset) + font->space;

/*
 * Draw callbacks provided to the glyph drawing function
 */
typedef struct {
	void(real x, real y) move;
	void(real x, real y) draw;
	void(real x1, real y1, real x2, real y2, real x3, real y3) curve;
} draw_calls_t;

/*
 * Draw a single glyph using the provide callbacks.
 */
real
glyph_path(*font_t font, int ucs4, *draw_calls_t calls)
{
	real	x1, y1, x2, y2, x3, y3, _x1, _y1;
	int	op;
	int	glyph_start = glyph_offset(font, ucs4);
	int	offset = glyph_draw(font, glyph_start);

	x1 = y1 = 0;

	int value() { return font->outlines[offset++]; }

	for (;;) {
		op = value();

		switch (op) {
		case 'm':
			x1 = value();
			y1 = value();
			calls->move (x1, y1);
			continue;
		case 'l':
			x1 = value();
			y1 = value();
			calls->draw (x1, y1);
			continue;
		case 'c':
			x3 = value();
			y3 = value();
			x2 = value();
			y2 = value();
			x1 = value();
			y1 = value();
			calls->curve (x3, y3, x2, y2, x1, y1);
			continue;
		case '2':
			/* Compute the equivalent cubic spline */
			_x1 = value();
			_y1 = value();
			x3 = x1 + 2 * (_x1 - x1) / 3;
			y3 = y1 + 2 * (_y1 - y1) / 3;
			x1 = value();
			y1 = value();
			x2 = x1 + 2 * (_x1 - x1) / 3;
			y2 = y1 + 2 * (_y1 - y1) / 3;
			calls->curve (x3, y3, x2, y2, x1, y1);
			continue;
		case 'e':
			break;
		default:
			printf("unknown font op 0x%02x '%c'\n", op, op);
			break;
		}
		break;
	}
	return glyph_width(font, glyph_start);
}

/*
 * Draw a sequence of glyphs using the provided callbacks,
 * stepping by the width of each glyph
 */

real
text_path(*font_t font, string s, *draw_calls_t calls)
{
	int l = String::length(s);
	real ret = 0.0;

	void move(real x1, real y1)
	{
		calls->move(x1 + ret, y1);
	}

	void draw(real x1, real y1)
	{
		calls->draw(x1 + ret, y1);
	}

	void curve(real x1, real y1, real x2, real y2, real x3, real y3)
	{
		calls->curve(x1 + ret, y1, x2 + ret, y2, x3 + ret, y3);
	}

	draw_calls_t text_calls = {
		.move = move,
		.draw = draw,
		.curve = curve
	};

	for (int i = 0; i < l; i++) {
		ret += glyph_path(font, s[i], &text_calls);
	}
	return ret;
}

/*
 * Text metrics information, used to measure
 * the bounds of a set of glyphs
 */
typedef struct {
	real    left_side_bearing;
	real    right_side_bearing;
	real    ascent;
	real    descent;
	real    width;
	real    font_ascent;
	real    font_descent;
} text_metrics_t;

/* Compute the metrics of a single glyph */
text_metrics_t
glyph_metrics(*font_t font, int ucs4)
{
	int	glyph_start = glyph_offset(font, ucs4);

	return (text_metrics_t) {
		.left_side_bearing = glyph_left(font, glyph_start),
		.right_side_bearing = glyph_right(font, glyph_start),
		.ascent = glyph_ascent(font, glyph_start),
		.descent = glyph_descent(font, glyph_start),
		.width = glyph_width(font, glyph_start),
		.font_ascent = font->ascent,
		.font_descent = font->descent,
	};
}

/* Compute the metrics of a list of glyphs */
text_metrics_t
text_metrics(*font_t font, string s)
{
	int l = String::length(s);
	real x = 0.0;
	text_metrics_t ret;

	for (int i = 0; i < l; i++) {
		text_metrics_t g = glyph_metrics(font, s[i]);
		g.left_side_bearing += x;
		g.right_side_bearing += x;
		g.width += x;
		if (i == 0)
			ret = g;
		else {
			ret.left_side_bearing = min(ret.left_side_bearing, g.left_side_bearing);
			ret.right_side_bearing = max(ret.right_side_bearing, g.right_side_bearing);
			ret.ascent = max(ret.ascent, g.ascent);
			ret.descent = max(ret.descent, g.descent);
			ret.width = g.width;
		}
		x = g.width;
	}
	return ret;
}

typedef struct {
	real	x, y;
} spoint_t;

typedef struct {
	spoint_t    a, b, c, d;
} spline_t;

typedef struct {
	spoint_t	top_left;
	spoint_t	bottom_right;
} rect_t;

bool
rect_is_empty(*rect_t r)
{
	return r->top_left.x >= r->bottom_right.x || r->top_left.y >= r->bottom_right.y;
}

/* Interpolate splines to lines until we hit the desired flatness */
void
_lerp_half (*spoint_t a, *spoint_t b, *spoint_t result)
{
	result->x = a->x + ((b->x - a->x) / 2);
	result->y = a->y + ((b->y - a->y) / 2);
}

void
_de_casteljau (*spline_t spline, *spline_t s1, *spline_t s2)
{
	spoint_t ab, bc, cd;
	spoint_t abbc, bccd;
	spoint_t final;

	_lerp_half (&spline->a, &spline->b, &ab);
	_lerp_half (&spline->b, &spline->c, &bc);
	_lerp_half (&spline->c, &spline->d, &cd);
	_lerp_half (&ab, &bc, &abbc);
	_lerp_half (&bc, &cd, &bccd);
	_lerp_half (&abbc, &bccd, &final);

	s1->a = spline->a;
	s1->b = ab;
	s1->c = abbc;
	s1->d = final;

	s2->a = final;
	s2->b = bccd;
	s2->c = cd;
	s2->d = spline->d;
}

real
_distance_to_point_squared (*spoint_t a, *spoint_t b)
{
	real dx = (b->x - a->x);
	real dy = (b->y - a->y);

	return dx*dx + dy*dy;
}

real
_distance_to_line_squared (*spoint_t p, *spoint_t p1, *spoint_t p2)
{
	/*
	 * Convert to normal form (AX + BY + C = 0)
	 *
	 * (X - x1) * (y2 - y1) = (Y - y1) * (x2 - x1)
	 *
	 * X * (y2 - y1) - Y * (x2 - x1) - x1 * (y2 - y1) + y1 * (x2 - x1) = 0
	 *
	 * A = (y2 - y1)
	 * B = (x1 - x2)
	 * C = (y1x2 - x1y2)
	 *
	 * distanceÂ² = (AX + BC + C)Â² / (AÂ² + BÂ²)
	 */
	real   A = p2->y - p1->y;
	real   B = p1->x - p2->x;
	real   C = p1->y * p2->x - p1->x * p2->y;
	real   den, num;

	num = A * p->x + B * p->y + C;
	if (num < 0)
		num = -num;
	den = A * A + B * B;
	if (den == 0)
		return _distance_to_point_squared (p, p1);
	else
		return (num * num) / den;
}

/*
 * Return an upper bound on the error (squared) that could
 * result from approximating a spline as a line segment
 * connecting the two endpoints
 */

real
_spline_error_squared (*spline_t spline)
{
	real berr, cerr;

	berr = _distance_to_line_squared (&spline->b, &spline->a, &spline->d);
	cerr = _distance_to_line_squared (&spline->c, &spline->a, &spline->d);

	if (berr > cerr)
		return berr;
	else
		return cerr;
}

/*
 * Pure recursive spline decomposition.
 */

void
_spline_decompose (void(real x, real y) draw,
		   *spline_t	spline,
		   real		tolerance_squared)
{
    if (_spline_error_squared (spline) <= tolerance_squared)
    {
	draw (spline->a.x, spline->a.y);
    }
    else
    {
	spline_t s1, s2;
	_de_casteljau (spline, &s1, &s2);
	_spline_decompose (draw, &s1, tolerance_squared);
	_spline_decompose (draw, &s2, tolerance_squared);
    }
}

/* Various matrix operations to support affine transformations */

typedef struct {
	real	xx, yx;
	real	xy, yy;
	real	x0, y0;
} matrix_t;

matrix_t
matrix_identity() {
	return (matrix_t) {
		.xx = 1, .xy = 0,
		.yx = 0, .yy = 1,
		.x0 = 0, .y0 = 0
	};
}

matrix_t
matrix_multiply(&matrix_t a, &matrix_t b)
{
	return (matrix_t) {
		.xx = a.xx * b.xx + a.yx * b.xy,
		.yx = a.xx * b.yx + a.yx * b.yy,
		.xy = a.xy * b.xx + a.yy * b.xy,
		.yy = a.xy * b.yx + a.yy * b.yy,
		.x0 = a.x0 * b.xx + a.y0 * b.xy + b.x0,
		.y0 = a.x0 * b.yx + a.y0 * b.yy + b.y0 };
}

matrix_t
matrix_translate (&matrix_t m, real tx, real ty)
{
	return matrix_multiply (&(matrix_t) {
			.xx = 1,  .yx = 0,
			.xy = 0,  .yy = 1,
			.x0 = tx, .y0 = ty },
		&m);
}

matrix_t
matrix_scale (&matrix_t m, real sx, real sy)
{
	return matrix_multiply (&(matrix_t) {
			.xx = sx, .yx =  0,
			.xy =  0, .yy = sy,
			.x0 =  0, .y0 =  0 },
		&m);
}

matrix_t
matrix_rotate (&matrix_t m, real a)
{
	real c = cos(a);
	real s = sin(a);
	return matrix_multiply (&(matrix_t) {
			.xx = c, .yx = s,
			.xy = -s,.yy = c,
			.x0 = 0, .y0 = 0 },
		&m);
}

matrix_t
matrix_sheer (&matrix_t m, real sx, real sy)
{
	return matrix_multiply(&(matrix_t) {
			.xx = 1, .yx = sx,
			.xy = sy, .yy = 1,
			.x0 = 0, .y0 = 0 },
		&m);
}

spoint_t
matrix_point (&matrix_t m, spoint_t p)
{
	return (spoint_t) {
		.x = m.xx * p.x + m.yx * p.y + m.x0,
		.y = m.xy * p.x + m.yy * p.y + m.y0
	};
};

spoint_t
matrix_distance (&matrix_t m, spoint_t p)
{
	return (spoint_t) {
		.x = m.xx * p.x + m.yx * p.y,
		.y = m.xy * p.x + m.yy * p.y
	};
};

spoint_t
spoint (real x, real y)
{
	return (spoint_t) {
		.x = x,
		.y = y
	};
}

/* Values provided on the command line */

real feed_rate = 100;		/* --speed */
real tolerance = 0.001;		/* --flatness */
real border = .1;		/* --border */
string output_name = "-";	/* --output */
string template_name = "";	/* --template */
string device_name = "";	/* --device */
real start_x = 0, start_y = 0;	/* --start-x, --start-y */
real delta_x = 4, delta_y = 1;	/* --delta-x, --delta-y */
real width = 4, height = 1;	/* --width, --height */
real columns = 1;		/* --columns */
real start_value, number;	/* --value, --number */
string text_value;		/* --text */
bool draw_rect = false;		/* --rect */
bool inches = true;		/* --inches */
bool millimeters = false;	/* --mm */
string share_dir = "@SHARE_DIR@"; /* --config-dir */
bool version = false;		/* --version */
bool oblique = false;		/* --oblique */

string project_version = "@VERSION@";
int user_argind;

/*
 * Device configuration structure. This contains all of the data
 * necessary to generate output for the target device
 */
typedef struct {
	string	start;		/* start string */
	string	bounds;		/* bounds format, given width and height */
	string	inch;		/* set inch mode */
	string	mm;		/* set mm mode */
	string	move;		/* move format, given X and Y */
	bool	speed;		/* whether draw is given speed */
	bool	y_invert;	/* whether Y coordinates are inverted (+up) */
	string	draw;		/* draw format, given X and Y (and maybe speed) */
	string	stop;		/* stop string */
} device_t;

device_t	device = {
	.start = "G90\nG17\n",		/* absolute mode, XY plane */
	.bounds = "",
	.inch = "G20\n",		/* inches mode */
	.mm = "G21\n",			/* mm mode */
	.move = "G00 X%f Y%f\n",	/* Move X, Y */
	.speed = true,			/* include speed in Draw */
	.y_invert = true,		/* +up */
	.draw = "G01 X%f Y%f F%f\n",	/* Draw X, Y, speed */
	.stop = "M30\n"			/* end program */
};

autoload JSON;

/*
 * Open a device configuration file. Try the given path first,
 * and if that fails, look in the device configuration directory
 */
file
device_open(string name)
{
	file f;
	try {
		f = File::open(name, "r");
	} catch File::open_error(string message, File::error_type error, string name) {
		f = File::open(share_dir + "/" + name, "r");
	}
	return f;
}

/* Read an entire file into a single string */
string
whole_file(string file_name)
{
	string	ret = "";
	twixt(file f = device_open(device_name); File::close(f)) {
		while (!File::end(f)) {
			string line = File::fgets(f);
			ret = ret + line;
		}
	}
	return ret;
}

/*
 * Extract data from a json value of specific type. Raise an error on
 * a type mismatch so that we can provide a more helpful message to
 * the user
 */

exception invalid_device(string name, string expected, string got, poly value);

/* Convert an internal type to the equivalent JSON type name */
string
json_typeof(poly value)
{
	switch (value) {
	case true:
	case "true":
		return "true";
	case false:
	case "false":
		return "false";
	case <>:
	case "null":
		return "null";
	default:
		break;
	}
	if (is_string(value))
		return "string";
	if (is_number(value))
		return "number";
	if (is_hash(value))
		return "object";
	if (is_array(value))
		return "array";
	return "unknown";
}

/* Extract a string value */
string
get_string(poly[string] h, string key, string def)
{
	if (hash_test(h, key)) {
		try {
			string s = h[key];
			return s;
		} catch invalid_argument(string message, int id, poly value) {
			raise invalid_device(key, "string", json_typeof(value), value);
		}
	}
	return def;
}

/*
 * Extract a boolean value. Allow booleans to be encoded as strings
 * for compatibility with pre-2.94 nickle
 */
bool
get_bool(poly[string] h, string key, bool def)
{
	if (hash_test(h, key)) {
		poly value = h[key];
		switch (value) {
		case true:
		case "true":
			return true;
		case false:
		case "false":
			return false;
		default:
			raise invalid_device(key, "bool", json_typeof(value), value);
		}
	}
	return def;
}

/* Extract a numeric value, either int or real */
real
get_number(poly[string] h, string key, real def)
{
	if (hash_test(h, key)) {
		try {
			real v = h[key];
			return v;
		} catch invalid_argument(string message, int id, poly value) {
			raise invalid_device(key, "number", json_typeof(value), value);
		}
	}
	return def;
}

/*
 * Load a device configuration from the provided filename. Leave existing
 * values unchanged if the configuration doesn't provide a new value
 */
void
load_device(string name)
{
	poly p = JSON::from_json(whole_file(name));
	poly[string] h = p;
	try {
		device.start = get_string(h, "start", device.start);
		device.bounds = get_string(h, "bounds", device.bounds);
		device.inch = get_string(h, "inch", device.inch);
		device.mm = get_string(h, "mm", device.mm);
		device.move = get_string(h, "move", device.move);
		device.draw = get_string(h, "draw", device.draw);
		device.speed = get_bool(h, "speed", device.speed);
		device.y_invert = get_bool(h, "y-invert", device.y_invert);
		device.stop = get_string(h, "stop", device.stop);
	} catch invalid_device(string key, string expected, string got, poly value) {
		File::fprintf(stderr, "%s: invalid value for \"%s\". Expected %s. Got %s (%v).\n", name, key, expected, got, value);
		exit(1);
	}
}

/*
 * Emit all of the startup values. Those include the 'start' string, a
 * possible bounds value and then one of the inch or millimeters
 * strings.
 */
void
gcode_start(file f)
{
	File::fprintf(f, "%s", device.start);
	if (device.bounds != "")
		File::fprintf(f, device.bounds, width, height);
	if (millimeters)
		File::fprintf(f, "%s", device.mm);
	else
		File::fprintf(f, "%s", device.inch);
}

/* Emit the stop string */
void
gcode_stop(file f)
{
	File::fprintf(f, "%s", device.stop);
}

/* Format the move output */
void
gcode_move(file f, real x, real y)
{
	File::fprintf(f, device.move, x, y);
}

/* Format the draw output, including the speed (feed rate) if used */
void
gcode_draw(file f, real x, real y)
{
	if (device.speed)
		File::fprintf(f, device.draw, x, y, feed_rate);
	else
		File::fprintf(f, device.draw, x, y);
}

/* Draw a rectangle by using a move and four draws */
void
gcode_rect(file f, rect_t r)
{
	gcode_move(f, r.top_left.x, r.top_left.y);
	gcode_draw(f, r.bottom_right.x, r.top_left.y);
	gcode_draw(f, r.bottom_right.x, r.bottom_right.y);
	gcode_draw(f, r.top_left.x, r.bottom_right.y);
	gcode_draw(f, r.top_left.x, r.top_left.y);
}

/* Render a text string scaled to the provided matrix */
void
text_to_gcode(file f, matrix_t m, string s)
{
	real last_x = 0.0, last_y = 0.0;

	void move(real x1, real y1)
	{
		spoint_t p = matrix_point(&m, spoint(x1, y1));
		gcode_move(f, p.x, p.y);
		last_x = x1;
		last_y = y1;
	}

	void draw(real x1, real y1)
	{
		spoint_t p = matrix_point(&m, spoint(x1, y1));
		gcode_draw(f, p.x, p.y);
		last_x = x1;
		last_y = y1;
	}

	void sdraw(real x, real y)
	{
		gcode_draw(f, x, y);
	}

	/*
	 * decompose a spline into line segments of the desired
	 * flatness and render a sequence of lines
	 */
	void curve(real x1, real y1, real x2, real y2, real x3, real y3)
	{
		spoint_t a = matrix_point(&m, spoint(last_x, last_y));
		spoint_t b = matrix_point(&m, spoint(x1, y1));
		spoint_t c = matrix_point(&m, spoint(x2, y2));
		spoint_t d = matrix_point(&m, spoint(x3, y3));
		spline_t	spline = {
			.a = a,
			.b = b,
			.c = c,
			.d = d,
		};
		_spline_decompose(sdraw, &spline, tolerance**2);
		gcode_draw(f, d.x, d.y);
		last_x = x3;
		last_y = y3;
	}

	draw_calls_t gcode_calls = {
		.move = move,
		.draw = draw,
		.curve = curve
	};

	text_path(&font, s, &gcode_calls);

}

/*
 * Support a gcode template file to describe where strings
 * should be placed
 */

typedef struct {
	int	letter;
	real	value;
} token_t;

token_t
read_token(file f)
{
	int letter;

	do {
		letter = File::getc(f);
	} while (letter < 'A' || 'Z' < letter);
	real value;
	File::fscanf(f, " %f", &value);
	return (token_t) {
		.letter = letter,
		.value = value
	};
}

/*
 * Parse a gcode file, computing the bounding box
 * for each polygon in the file
 */
rect_t[...]
parse_template(string file_name)
{
	int code = -1;
	rect_t[...] ret = {};
	rect_t cur = {
		.top_left = { .x = 0, .y = 0 },
		.bottom_right = { .x = 0, .y = 0 }
	};

	void add_rect() {
		if (!rect_is_empty(&cur)) {
			ret[dim(ret)] = cur;
		}
		cur = (rect_t) {
			.top_left = { .x = 0, .y = 0 },
			.bottom_right = { .x = 0, .y = 0 }
		};
	}

	twixt(file f = File::open(file_name, "r"); File::close(f)) {
		real x, y;
		for (;;) {
			try {
				token_t token = read_token(f);
				switch (token.letter) {
				case 'G':
					code = floor(token.value);
					break;
				case 'X':
					x = token.value;
					switch (code) {
					case 0:
						add_rect();
						cur.top_left.x = x;
						cur.bottom_right.x = x;
						break;
					case 1:
						cur.top_left.x = min(cur.top_left.x, x);
						cur.bottom_right.x = max(cur.bottom_right.x, x);
						break;
					}
					break;
				case 'Y':
					y = token.value;
					switch (code) {
					case 0:
						add_rect();
						cur.top_left.y = y;
						cur.bottom_right.y = y;
						break;
					case 1:
						cur.top_left.y = min(cur.top_left.y, y);
						cur.bottom_right.y = max(cur.bottom_right.y, y);
						break;
					}
					break;
				}
			} catch File::io_eof(file f) {
				add_rect();
				break;
			}
		}
	}
	return ret;
}

/*
 * Render the provided string into the specified rectangle
 * by scaling the text to fit subtracting off the 'border'
 * on all four sides
 */

real oblique_sheer = 0.1;

void
text_into_rect(file f, rect_t rect, string line)
{
	if (draw_rect)
		gcode_rect(f, rect);

	/* Compute the size of the target rectangle, subtracting the border. */
	real rect_width = rect.bottom_right.x - rect.top_left.x - border * 2;
	real rect_height = rect.bottom_right.y - rect.top_left.y - border * 2;

	/*
	 * Compute the size of the text. Use the ink metrics for height
	 * so that the text ends up looking centered
	 */
	text_metrics_t metrics = text_metrics(&font, line);
	real text_width = metrics.right_side_bearing - metrics.left_side_bearing;
	real text_height = metrics.ascent + metrics.descent;
	if (oblique)
		text_width += text_height * oblique_sheer;

	real scale = 0.0;

	/* Check aspect ratios to pick which to use for scale */
	if (text_width / text_height > rect_width / rect_height) {
		scale = rect_width / text_width;
	} else {
		scale = rect_height / text_height;
	}

	/* Center the scaled text in the rectangle */
	real text_off_x = (rect_width - text_width * scale) / 2;
	real text_off_y = (rect_height - text_height * scale) / 2;

	/*
	 * Compute a transformation matrix to scale, translate and
	 * possibly mirror the text
	 */
	matrix_t matrix = matrix_identity();
	matrix = matrix_translate(&matrix, text_off_x + rect.top_left.x + border, text_off_y + rect.top_left.y + border);
	if (oblique)
		matrix = matrix_sheer(&matrix, -oblique_sheer, 0);
	matrix = matrix_scale(&matrix, scale, scale);
	if (device.y_invert)
		matrix = matrix_scale(&matrix, 1, -1);
	else
		matrix = matrix_translate(&matrix, 0, metrics.ascent);

	/* Render the text */
	text_to_gcode(f, matrix, line);
}

autoload ParseArgs;

ParseArgs::argdesc argd = {
	.args = {
		{
			.var = { .arg_flag = &version },
			.abbr = 'V',
			.name = "version",
			.desc = "Print version and exit"
		},
		{
			.var = { .arg_flag = &inches },
			.abbr = 'i',
			.name = "inch",
			.expr_name = "inch",
			.desc = "Use inch units",
		},
		{
			.var = { .arg_flag = &millimeters },
			.abbr = 'm',
			.name = "mm",
			.expr_name = "millimeters",
			.desc = "Use millimeter units",
		},
		{
			.var = { .arg_flag = &draw_rect },
			.abbr = 'r',
			.name = "rect",
			.expr_name = "rect",
			.desc = "Draw bounding rectangles"
		},
		{
			.var = { .arg_flag = &oblique },
			.abbr = 'O',
			.name = "oblique",
			.expr_name = "oblique",
			.desc = "Draw the glyphs using a sheer transform"
		},
		{
			.var = { .arg_real = &tolerance },
			.abbr = 'f',
			.name = "flatness",
			.expr_name = "flatness",
			.desc = "Spline decomposition tolerance"
		},
		{
			.var = { .arg_real = &feed_rate },
			.abbr = 's',
			.name = "speed",
			.expr_name = "speed",
			.desc = "Feed rate"
		},
		{
			.var = { .arg_string = &template_name },
			.abbr = 't',
			.name = "template",
			.expr_name = "template",
			.desc = "Template file name"
		},
		{
			.var = { .arg_string = &device_name },
			.abbr = 'd',
			.name = "device",
			.desc = "Device config file"
		},
		{
			.var = { .arg_string = &output_name },
			.abbr = 'o',
			.name = "output",
			.expr_name = "output",
			.desc = "Output file name"
		},
		{
			.var = { .arg_real = &border },
			.abbr = 'b',
			.name = "border",
			.expr_name = "border",
			.desc = "Border width"
		},
		{
			.var = { .arg_real = &start_x },
			.abbr = 'x',
			.name = "start-x",
			.expr_name = "start-x",
			.desc = "Starting X for boxes",
		},
		{
			.var = { .arg_real = &start_y },
			.abbr = 'y',
			.name = "start-y",
			.expr_name = "start-y",
			.desc = "Starting Y for boxes",
		},
		{
			.var = { .arg_real = &width },
			.abbr = 'w',
			.name = "width",
			.expr_name = "width",
			.desc = "Box width",
		},
		{
			.var = { .arg_real = &height },
			.abbr = 'h',
			.name = "height",
			.expr_name = "height",
			.desc = "Box height",
		},
		{
			.var = { .arg_real = &delta_x },
			.abbr = 'X',
			.name = "delta-x",
			.expr_name = "delta-x",
			.desc = "X offset between boxes",
		},
		{
			.var = { .arg_real = &delta_y },
			.abbr = 'Y',
			.name = "delta-y",
			.expr_name = "delta-y",
			.desc = "Y offset between boxes",
		},
		{
			.var = { .arg_real = &columns },
			.abbr = 'c',
			.name = "columns",
			.expr_name = "columns",
			.desc = "Number of columns of boxes",
		},
		{
			.var = { .arg_real = &start_value },
			.abbr = 'v',
			.name = "value",
			.expr_name = "value",
			.desc = "Initial text numeric value",
		},
		{
			.var = { .arg_real = &number },
			.abbr = 'n',
			.name = "number",
			.expr_name = "number",
			.desc = "Number of numeric values",
		},
		{
			.var = { .arg_string = &text_value },
			.abbr = 'T',
			.name = "text",
			.expr_name = "string",
			.desc = "Text string"
		},
		{
			.var = { .arg_string = &share_dir },
			.abbr = 'C',
			.name = "config-dir",
			.expr_name = "dir",
			.desc = "Directory containing device configuration files"
		},
	},
	.unknown = &user_argind
};

exception done();

void
main()
{
	rect_t[] template;
	ParseArgs::parseargs(&argd, &argv);

	if (version) {
		printf("%s %s\n", argv[0], project_version);
		exit(0);
	}

	if (is_uninit(&user_argind))
		user_argind = dim(argv);
	string[] rest = (string[dim(argv) - user_argind]) { [i] = argv[i+user_argind] };
	argv = rest;
	file output = stdout;

	if (device_name != "")
		load_device(device_name);

	if (output_name == "-")
		output = stdout;
	else
		output = File::open(output_name, "w");

	file my_open(string name) {
		if (name == "-")
			return stdin;
		return File::open(name, "r");
	}

	void my_close(file f) {
		if (f != stdin)
			File::close(f);
	}

	if (template_name != "")
		template = parse_template(template_name);

	/* Return the next line of text */
	string next_line()
	{
		if (!is_uninit(&start_value)) {
			/* using sequential numeric values */
			if (is_uninit(&number)) {
				/*
				 * If no template provided, stop after
				 * one, otherwise fill all of the
				 * template boxes
				 */
				if (template_name == "")
					number = 1;
				else
					number = -1;
			}
			if (number == 0)
				raise done();
			number--;
			return sprintf("%f", start_value++);
		} else {
			static int i = 0;
			static file f;
			static bool is_open = false;

			if (is_open && File::end(f)) {
				my_close(f);
				is_open = false;
			}
			if (!is_open) {
				if (!is_uninit(&text_value)) {
					/*
					 * Start with any string provided on the command line
					 * This can contain newlines, so just read it as if it
					 * were a file
					 */
					f = File::string_read(text_value);
					make_uninit(&text_value);
				} else {
					if (i >= dim(argv))
						raise done();
					f = my_open(argv[i]);
					i++;
				}
				is_open = true;
			}
			/* Delete any trailing newline */
			return String::chump(File::fgets(f));
		}
	}

	/* Return the next box to paint text into */
	rect_t
	next_rect()
	{
		if (template_name != "") {
			/* Use a template, return the next box */
			static int t = 0;
			if (t == dim(template))
				raise done();
			return template[t++];
		} else {
			/*
			 * Use the provided parameters to define a
			 * grid of boxes each width/height, starting
			 * at start-x/start-y and offset by
			 * delta-x/delta-y
			*/
			static int c = 0;
			static real current_x;
			static real current_y;
			static bool started = false;
			if (!started) {
				current_x = start_x;
				current_y = start_y;
				started = true;
			} else {
				current_x += delta_x;
				c++;
				if (c == columns) {
					current_x = start_x;
					current_y += delta_y;
					c = 0;
				}
			}
			return (rect_t) {
				.top_left = { .x = current_x, .y = current_y },
				.bottom_right = { .x = current_x + width, .y = current_y + height }
			};
		}
	}

	gcode_start(output);

	try {
		for (;;) {
			string line = next_line();
			rect_t rect = next_rect();
			printf("%f,%f - %f,%f \"%s\"\n",
			       rect.top_left.x,
			       rect.top_left.y,
			       rect.bottom_right.x,
			       rect.bottom_right.y,
			       line);
			text_into_rect(output, rect, line);
		}
	} catch done() {
	}

	gcode_stop(output);
	if (output != stdout)
		File::close(output);

	exit(0);
}

main();
